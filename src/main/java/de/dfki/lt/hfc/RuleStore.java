package de.dfki.lt.hfc;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TreeMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import gnu.trove.map.hash.TCustomHashMap;
import gnu.trove.set.hash.THashSet;

/**
 * a rule consists of an antecedent and a consequent;
 * both antecedent and consequent are represented as a sequence of tuples,
 * interpreted conjunctively;
 * each tuple element is either a URI, an XSD atom, or a variable (new!)
 * interpreted locally within the scope of the rule;
 * blank nodes are not allowed in a rule, but can, of course, be generated
 * through RHS-only free variables;
 * note: blank nodes are clearly allowed in ground tuples, i.e., facts,
 * which are matched against tuples in the antecedent of a rule;
 * textually, a rule is encoded as an extension of the N-Triples syntax,
 * where each tuple both in antecedent and consequent position must occupy
 * a single line in the text file;
 * antecedent and consequent are separated by "->" (again in a single line);
 * a rule starts with a rule name (single line) and ends with an _empty_ line;
 * comments are lines starting with the '#' character; comments are NOT allowed
 * _inside_ a rule definition;
 * a priority equals 0 (or even a negative int) switches off the rule
 * <p>
 * this rule extension of N-Triples is called RDL for
 * Rule (or Rewrite) Description Language
 *
 * <rule>    ::= <name> [<prior>] <ante> <imply> <cons> [<test>] [action] <newline>
 * <name>    ::= "$" <nwchar>^+ <newline>
 * <prior>   ::= "&priority" <posint0> <newline>
 * <ante>    ::= {<tuple> <newline>}^+
 * <imply>   ::= {"->" | "-->" | "=>" | |==>"} <newline>
 * <cons>    ::= {<tuple> <newline>}^+
 * <test>    ::= "@test" <newline> {<pred> <newline>}^*
 * <action>  ::= "@action" <newline> {<func> <newline>}^*
 * <pred>    ::= <var> "!=" {<var> | <uri> | <atom>} |
 * <nwchar>^+ {<var> | <uri> | <atom>}^*
 * <func>    ::= <var> = <nwchar>^+ {<var> | <uri> | <atom>}^*
 * <var>     ::= "?"<nwchar>^+
 * <tuple>   ::= {<var> | <uri> | <atom>}^+
 * <uri>     ::= "<" <nwchar>^+ ">"
 * <atom>    ::= "\""  <char> "\"" ["@" <langtag> | "^^" <xsdtype>]
 * <char>    ::= any character, incl. whitespaces, numbers, even '\"'
 * <nwchar>  ::= any NON-whitespace character
 * <posint0> ::= any positive integer, including 0
 * <p>
 * note that the EBNF of RDL requires that the antecedent and consequent
 * take at least _one_ tuple; so neither an empty antecedent (fact) nor an
 * empty consequent (query) is possible
 * <p>
 * note that fresh new individuals are generated by using _unbounded_
 * variables on the RHS of a rule
 * <p>
 * example
 * <p>
 * # a rule for encoding OWL transitive properties in RDL
 * $OWL_Transitive_Property
 * ?p <rdf:type> <owl:TransitiveProperty>
 * ?x ?p ?y
 * ?y ?p ?z
 * ->
 * ?x ?p ?z
 *
 * @author (C) Hans-Ulrich Krieger
 * @version Wed Jun 22 15:20:51 CEST 2016
 * @see de.dfki.lt.hfc.Rule
 * @see de.dfki.lt.hfc.ForwardChainer
 * @since JDK 1.5
 */
public final class RuleStore {

  /**
   * since constants (or literals = URIs or XSD atoms) are assigned positive
   * ints as representatives, 0 (zero) can be used at certain places to indicate
   * that a variable is unbound or its value is not of interest (as used in
   * predicate NoValue)
   *
   * @see de.dfki.lt.hfc.operators.NoValue
   */
  public static final int UNBOUND = 0;
  /**
   * only for internal use during the relational variable to id assignment
   */
  private static final int RELVAR_OFFSET = -1000000000;
  private static final Logger logger = LoggerFactory.getLogger(RuleStore.class);

  /**
   */
  public boolean reorderAntecedent = true;
  
  /**
   * a TupleStore object used to interface rule tuples with the initial base tuples
   */
  protected TupleStore tupleStore;
  
  /**
   * a list of all rules known to RuleStore
   */
  protected ArrayList<Rule> allRules = new ArrayList<Rule>();
  /**
   * a data structure that maps "equivalent" LHS clauses (even across rules) to binding
   * tables (plus additional info), coming from the index
   */
  protected Map<int[], Proxy> equivalentClauses =
          new TCustomHashMap<int[], Proxy>(TupleIntStore.DEFAULT_HASHING_STRATEGY);
  /**
   * current line number;
   * make it a global field, since otherwise too many methods need to be extended by a further argument
   */
  protected int lineNo = 0;
  /**
   * the private rule comparator that is used by sortRules()
   */
  private RuleComparator ruleComparator = new RuleComparator();
  /**
   * the set of all rule _names_ (for a primitive form of duplicate detection)
   */
  private HashSet<String> allRuleNames = new HashSet<String>();
  /**
   * only for internal use during functional+relational variable-to-id assignment
   */
  private int varCounter = -1;
  /**
   * only for internal use during functional variable to id assignment (I have skipped
   * the prefix "functional" for this field name);
   * note: we do not need an inverse table;
   * note: there exists a similar mapping objectToId for constants (to positive
   * ints) in class TupleStore that is independent of the rules addressed here
   */
  private HashMap<String, Integer> varToId;  // is created brand-new for each rule
  /**
   * only for internal use during the relational variable to id assignment;
   *
   * @see RuleStore.varToId for a similar mapping
   */
  private HashMap<String, Integer> relationalVarToId = new HashMap<String, Integer>();
  /**
   * new for each rule object;
   * represents a mapping from proxies for relational variabels to their functional
   * counterparts;
   * even non-complex relational variables are represented here through singleton lists
   */
  private HashMap<Integer, ArrayList<Integer>> proxyIdToFunctionalIds;

  /**
   * creates an empty rule store
   */
  public RuleStore(TupleStore store) {
    this.tupleStore = store;
  }

  /**
   * external representation: variables start with the '?' character
   */
  public static boolean isVariable(String literal) {
    return literal.startsWith("?");
  }

  /**
   * internal representation: variables (both functional and relational) are represented
   * by negative numbers
   */
  public static boolean isVariable(int id) {
    return (id < 0);
  }

  /**
   * characterize "ordinary" functional variables
   *
   * @see RuleStore.isVariable()
   */
  public static boolean isFunctionalVariable(String literal) {
    return ((literal.charAt(0) == '?') && (literal.charAt(1) != '?'));
  }

  /**
   * "ordinary" functional variables
   *
   * @see RuleStore.isVariable()
   */
  public static boolean isFunctionalVariable(int id) {
    return ((id < 0) && (id >= RuleStore.RELVAR_OFFSET));
  }

  /**
   * external representation: relational variables start with the "??" prefix
   */
  public static boolean isRelationalVariable(String literal) {
    return literal.startsWith("??");
  }

  /**
   * relational variables (like functional ones) are assigned negative ints, smaller
   * than RuleStore.RELVAR_OFFSET -- since a relational variable is associated with
   * a functional variable from the LHS of a rule, its id is definded as
   * id(??var) := RELVAR_OFFSET - id(?var)
   *
   * @see RuleStore.RELVAR_OFFSET == -1000000000
   * @see Integer.MIN_VALUE == -2147483648
   */
  public static boolean isRelationalVariable(int id) {
    return (id < RuleStore.RELVAR_OFFSET);
  }

  /**
   * complex relational variables start with "??("
   * example: ??(subj obj)
   */
  public static boolean isComplexRelationalVariable(String literal) {
    return literal.startsWith("??(");
  }

  /**
   * Return all rules contained in this rule store
   */
  public List<Rule> getAllRules() {
    return this.allRules;
  }

  /**
   * obtains the id of the corresponding functional variable, given the relational
   * variable name;
   * note: I do NOT check whether there is such a functional var key in this.varToId
   */
  private Integer getFunId(String relvar) {
    return this.varToId.get(relvar.substring(1));
  }

  /**
   * obtains the id of the corresponding functional variable, given the relational
   * variable id;
   * note: I do NOT check whether there is such a functional var key in this.varToId
   *
  private Integer getFunId(Integer relvar) {
    return (relvar - RuleStore.RELVAR_OFFSET);
  }
  */

  /**
   * extends a rule object by its internal representation of the antecedent;
   * checks for various potential errors
   */
  private boolean makeAntecedent(ArrayList<int[]> ante, Rule rule) {
    if (rule == null)
      return tupleStore.sayItLoud(this.lineNo, ": missing rule name");
    else if (rule.getAntecedent() != null)
      return tupleStore.sayItLoud(this.lineNo, ": antecedent specified twice");
    else if (ante.size() == 0)
      return tupleStore.sayItLoud(this.lineNo, ": empty antecedent");
    else {
      // further check whether ante elements at position i are equal null,
      // indicating that the i-th ante tuple is invalid
      for (int i = 0; i < ante.size(); i++) {
        if (ante.get(i) == null)
          return tupleStore.sayItLoud(this.lineNo, ": antecedent contains invalid tuple(s)");
      }
      rule.setAntecedent(ante);
      return true;
    }
  }

  /**
   * extends a rule object by its internal representation of the consequent;
   * checks for various potential errors;
   * internally records LHS only one time occuring variables (don't cares)
   * and free RHS only variables (that will lead to introduction of blank
   * nodes during rule application);
   * finally enters the final rule object into the set of all rules
   */
  private boolean makeConsequent(ArrayList<int[]> cons, Rule rule) {
    if (cons.size() == 0)
      return tupleStore.sayItLoud(this.lineNo, ": empty consequent");
    // further check whether cons elements at position i are equal null,
    // indicating that the i-th cons tuple is invalid
    for (int i = 0; i < cons.size(); i++)
      if (cons.get(i) == null)
        return tupleStore.sayItLoud(this.lineNo, ": consequent contains invalid tuple(s)");
    rule.setConsequent(cons);
    // rule name, ante, and cons proper, so check for special LHS/RHS variables
    return handleSpecialVariables(rule);
  }

  /**
   * reorders the antecedent of a rule according to the heuristic implemented by the comparator
   *
   * @see de.dfki.lt.hfc.ClauseComparator
   */
  private void reorderAntecedent(Rule rule) {
    if (this.reorderAntecedent) {
      ClauseComparator cc = new ClauseComparator(rule.dontCareVariables, this.tupleStore);
      Arrays.sort(rule.ante, cc);
    }
  }

  /**
   * determines which of the LHS clauses will go together during global LHS match
   * through the use of join(); note that inequality constraints (as well as general
   * constraints) also need to be considered here, e.g.,
   * ?x <p> ?_1, ?_2 <q> ?y, ?x != ?y -> ...
   * usually, one will have independent clusters of LHS clauses (instead of having only
   * one);
   * further examples:
   * ?a <p> ?b, ?c <q> ?d, ?e <r> ?f, ?a ?c ?e -> ...
   * ?q <rdf:type> ?c, ?r <owl:onProperty> ?p, ?r <owl:someValuesFrom> ?c, ?i ?p ?q -> ...
   * <p>
   * NOTE: at the moment, computeAmalgamation() does NOT take in-eqs, tests, and actions
   * into account, thus the LHS clusters need to be merged into a mega cluster in
   * ForwardChainer.prepareInstantiation() in order to apply restrict() (for ineqs
   * and predicates) and to access information properly (for actions)
   */
  private void computeAmalgamation(Rule rule) {
    // keep track of common vars and their positions
    ArrayList<HashSet<Integer>> variables = new ArrayList<HashSet<Integer>>();
    ArrayList<ArrayList<Integer>> positions = new ArrayList<ArrayList<Integer>>();
    // add info from first LHS clause
    variables.add(new HashSet<Integer>(rule.localQueryBindings[0].properVariables));
    ArrayList<Integer> pos = new ArrayList<Integer>();
    pos.add(0);
    positions.add(pos);
    ArrayList<Integer> delete = new ArrayList<Integer>();
    HashSet<Integer> vars, varsInter;
    for (int i = 1; i < rule.localQueryBindings.length; i++) {
      delete.clear();
      vars = rule.localQueryBindings[i].properVariables;
      for (int j = 0; j < variables.size(); j++) {
        varsInter = new HashSet<Integer>(variables.get(j));
        varsInter.retainAll(vars);
        if (!varsInter.isEmpty()) {
          delete.add(j);
          positions.get(j).add(i);
          variables.get(j).addAll(vars);
        }
      }
      if (delete.isEmpty()) {
        variables.add(vars);
        pos = new ArrayList<Integer>();
        pos.add(i);
        positions.add(pos);
      } else {
        HashSet<Integer> varset0 = variables.get(delete.get(0));
        ArrayList<Integer> poslist0 = positions.get(delete.get(0));
        // walk backwards, otherwise indices lead to wrongly accessed elements
        for (int j = delete.size() - 1; j > 0; j--) {
          varset0.addAll(variables.get(delete.get(j)));
          for (int k = 0; k < positions.get(delete.get(j)).size(); k++) {
            Integer p = positions.get(delete.get(j)).get(k);
            if (!poslist0.contains(p))
              poslist0.add(p);
          }
          variables.remove(delete.get(j).intValue());
          positions.remove(delete.get(j).intValue());
        }
      }
    }
    if ((positions.size() > 1))
      logger.debug("{}: more than 1 LHS cluster found", rule.name);
    // record the position info so that it can be used at run time
    computeClusters(positions, variables, rule);
  }

  /**
   * bundles information that belongs to a cluster of dependent LHS clauses; e.g.,
   * list of LHS clauses, set of proper LHS variables, applicable list of var-var
   * and list of var-const ineqs;
   * the remaining applicable (RHS) in-eqs for the mega cluster are also determined
   * here;
   * note that the binding table that arises from joins of local tables are also
   * stored here
   */
  private void computeClusters(ArrayList<ArrayList<Integer>> positions,
                               ArrayList<HashSet<Integer>> variables,
                               Rule rule) {
    Cluster[] result = new Cluster[positions.size()];
    Cluster cluster;
    //ArrayList<Integer> varvarIneqs;
    //ArrayList<Integer> varconstIneqs;
    Integer left, right;
    Iterator<Integer> it;
    ArrayList<Integer> remainingIneqs = new ArrayList<Integer>(rule.inEqConstraints);
    ArrayList<Integer> ineqs;
    ArrayList<Predicate> remainingTests = new ArrayList<Predicate>(rule.tests);
    Iterator<Predicate> pit;
    Predicate pred;
    int arg;
    boolean remains;
    for (int i = 0; i < positions.size(); i++) {
      cluster = new Cluster();
      result[i] = cluster;
      // process in-eq constraints
      ineqs = remainingIneqs;
      remainingIneqs = new ArrayList<Integer>();
      cluster.positions = positions.get(i);
      cluster.variables = variables.get(i);
      cluster.varvarIneqs = new ArrayList<Integer>();
      cluster.varconstIneqs = new ArrayList<Integer>();
      it = ineqs.iterator();
      while (it.hasNext()) {
        left = it.next();
        right = it.next();
        if (!cluster.variables.contains(left)) {
          remainingIneqs.add(left);
          remainingIneqs.add(right);
        } else if (RuleStore.isVariable(right)) {
          if (!cluster.variables.contains(right)) {
            remainingIneqs.add(left);
            remainingIneqs.add(right);
          } else {
            cluster.varvarIneqs.add(left);
            cluster.varvarIneqs.add(right);
          }
        } else {
          cluster.varconstIneqs.add(left);
          cluster.varconstIneqs.add(right);
        }
      }
      // process general predicates
      cluster.tests = new ArrayList<Predicate>();
      pit = remainingTests.iterator();
      while (pit.hasNext()) {
        pred = pit.next();
        remains = false;
        clusteronlyvars:
        for (int l = 0; l < pred.args.length; l++) {
          arg = pred.args[l];
          if (RuleStore.isVariable(arg)) {
            if (RuleStore.isRelationalVariable(arg)) {
              for (Integer funvarid : this.proxyIdToFunctionalIds.get(arg)) {
                assert (funvarid != null);
                if (!cluster.variables.contains(funvarid)) {
                  remains = true;
                  break clusteronlyvars;
                }
              }
            }
            // arg is a functional var
            else if (!cluster.variables.contains(arg)) {
              remains = true;
              break clusteronlyvars;
            }
          }
        }
        if (!remains) {
          // pred contains only variables from the i-th cluster
          cluster.tests.add(pred);
          pit.remove();
        }
      }
    }
    // record cluster array in the rule object
    rule.clusters = result;
    // already create mega cluster at this point and add remaining in-eqs to it
    rule.megaCluster = new Cluster();
    rule.megaCluster.varvarIneqs = new ArrayList<Integer>();
    rule.megaCluster.varconstIneqs = new ArrayList<Integer>();
    it = remainingIneqs.iterator();
    while (it.hasNext()) {
      left = it.next();
      right = it.next();
      if (RuleStore.isVariable(right)) {
        rule.megaCluster.varvarIneqs.add(left);
        rule.megaCluster.varvarIneqs.add(right);
      } else {
        rule.megaCluster.varconstIneqs.add(left);
        rule.megaCluster.varconstIneqs.add(right);
      }
    }
    // the test that stay in remainingTests are the tests for the mega cluster
    rule.megaCluster.tests = remainingTests;
  }

  /**
   * stores the don't care variables (LHS) and the blank node introducing
   * variables of the RHS in the rule object
   */
  private boolean handleSpecialVariables(Rule rule) {
    HashSet<Integer> lhsVars = new HashSet<Integer>();
    HashSet<Integer> rhsVars = new HashSet<Integer>();
    HashMap<Integer, Integer> noOfOcc = new HashMap<Integer, Integer>();
    //check ANTECEDENT
    for (int[] tuple : rule.getAntecedent())
      for (int i = 0; i < tuple.length; i++)
        if (RuleStore.isVariable(tuple[i])) {
          lhsVars.add(tuple[i]);
          if (noOfOcc.containsKey(tuple[i]))
            noOfOcc.put(tuple[i], noOfOcc.get(tuple[i]) + 1);
          else
            noOfOcc.put(tuple[i], 1);
        }
    // check CONSEQUENT
    for (int[] tuple : rule.getConsequent())
      for (int i = 0; i < tuple.length; i++)
        if (RuleStore.isVariable(tuple[i])) {
          rhsVars.add(tuple[i]);
          if (noOfOcc.containsKey(tuple[i]))
            noOfOcc.put(tuple[i], noOfOcc.get(tuple[i]) + 1);
          else
            noOfOcc.put(tuple[i], 1);
        }
    Integer val;  // reuse val at several places
    // check PREDICATES -- predicate variables MUST be LHS-only variables
    // (1) in-equalities
    for (int i = 0; i < rule.inEqConstraints.size(); i++) {
      // ineqs only refer to LHS variables!
      val = rule.inEqConstraints.get(i);
      if (RuleStore.isVariable(val)) {
        if (!lhsVars.contains(val))
          return tupleStore.sayItLoud(rule.name + ": in-eq variable does not refer to LHS");
        noOfOcc.put(val, noOfOcc.get(val) + 1);
      }
    }
    // (2) general predicates; note: arguments are either functional variables,
    //     relational variables, URIs, or XSD atoms;
    //     NOTE: checking whether predicate variables (functional, ordinary relational &
    //           complex relational) have a functional LHS counterpart is already achieved
    //           in evaluateSpecialVariable()
    for (Predicate predicate : rule.tests) {
      for (int i = 0; i < predicate.args.length; i++) {
        val = predicate.args[i];
        if (RuleStore.isVariable(val)) {  // URIs and atoms are not of interest here
          if (RuleStore.isRelationalVariable(val)) {
            // use proxyIdToFunctionalIds (individual for each rule) to find the corresponding
            // functional variable IDs
            for (Integer funvarid : this.proxyIdToFunctionalIds.get(val))
              noOfOcc.put(funvarid, noOfOcc.get(funvarid) + 1);
          } else
            noOfOcc.put(val, noOfOcc.get(val) + 1);
        }
      }
    }
    // check ACTIONS
    //   * result var is NOT a blank node var and must occur only on the RHS
    //   * arg vars need to be LHS-only vars
    //   * [ WHY? if we would guarantee that the var is bound, everything is fine! ]
    for (Function function : rule.actions) {
      // binder var must be a RHS var
      val = function.result;
      if (!rhsVars.contains(val) || lhsVars.contains(val))
        return tupleStore.sayItLoud(rule.name + ": binder variable in action does not refer to RHS");
      noOfOcc.put(val, noOfOcc.get(val) + 1);
      for (int i = 0; i < function.args.length; i++) {
        val = function.args[i];
        if (RuleStore.isVariable(val)) {
          if (!lhsVars.contains(val))
            return tupleStore.sayItLoud(rule.name + ": argument variable in action does not refer to LHS");
          noOfOcc.put(val, noOfOcc.get(val) + 1);
          // furthermore, do add function argument variables to RHS vars, since they are
          // needed to compute the function result; otherwise, they will be projected
          // away by ForwardChainer.performReferentialInstantiation()
          rhsVars.add(val);
        }
      }
    }
    // compute proper, blank node, and dont't care variables
    rule.properVariables = new HashSet<Integer>(lhsVars);
    rule.properVariables.addAll(rhsVars);
    rule.rhsVariables = new HashSet<Integer>(rhsVars);
    HashSet<Integer> lhsVars2 = new HashSet<Integer>(lhsVars);
    lhsVars.removeAll(rhsVars);
    rule.dontCareVariables = new HashSet<Integer>();
    for (int i : lhsVars) {
      if (noOfOcc.get(i) == 1)
        // only single occurences count
        rule.dontCareVariables.add(i);
    }
    if ((rule.dontCareVariables.size() > 0))
      logger.debug("{}: {}  don't care variables",
          rule.name, rule.dontCareVariables.size());
    rhsVars.removeAll(lhsVars2);
    if ((rhsVars.size() > 0))
      logger.debug("{}: {}  blank node vars", rule.name, rhsVars.size());
    rule.blankNodeVariables = rhsVars;
    // make sure that rule.rhsVariables does NOT contain any (RHS) blank node variables
    rule.rhsVariables.removeAll(rule.blankNodeVariables);
    // proper variables are those which are neither don't care nor blank node variables
    rule.properVariables.removeAll(rule.dontCareVariables);
    rule.properVariables.removeAll(rule.blankNodeVariables);
    return true;
  }

  /**
   * generates a tuple from a textual tokenized representation;
   * checks for various potential errors and translates the external
   * into an internal representation
   */
  protected int[] makeTuple(ArrayList<String> tuple) {
    // check whether external representation is valid for a rule tuple
    if (! tupleStore.isValidRuleTuple(tuple, lineNo))
      // if not, return null to indicate this
      return null;
    else
      return internalizeTuple(tuple);
  }

  /**
   * internalizeTuple() maps array lists of strings to int arrays of unique
   * ints;
   * positive ints (incl. 0) indicate (global) URIs and (global) XSD atoms,
   * whereas negative numbers are reserved for variables, treated locally
   */
  private int[] internalizeTuple(ArrayList<String> stringTuple) {
    int[] intTuple = new int[stringTuple.size()];
    String arg;
    int id;
    for (int i = 0; i < stringTuple.size(); i++) {
      arg = stringTuple.get(i);
      if (RuleStore.isVariable(arg)) {
        if (this.varToId.containsKey(arg))
          intTuple[i] = this.varToId.get(arg);
        else {
          id = this.varCounter--;  // _decrement_ counter !
          this.varToId.put(arg, id);
          intTuple[i] = id;
        }
      } else {
        // URIs and XSD atoms must be treated globally
        // check whether URI or atom occurs in initial fact base
        if (!this.tupleStore.isConstant(arg))
          logger.debug("  " + this.lineNo + ": " + arg + " not in initial fact base");
        
        id = this.tupleStore.putObject(arg);
        intTuple[i] = id;
      }
    }
    // even this is a rule tuple, add a reference to the tuple store to
    // guarantee proper decoding the call to toString()
    return intTuple;
  }

  /**
   * read in all tests directly following "@test" for later evaluation
   */
  private String readTests(BufferedReader br, ArrayList<String> tests) throws IOException {
    String line;
    // @test already consumed
    while ((line = br.readLine()) != null) {
      line = line.trim();
      ++this.lineNo;
      if ((line.length() == 0) || (line.equals("@action")))
        return line;
      else
        tests.add(line);
    }
    return "";
  }

  /**
   * transforms in-eqs and predicates to internal form
   */
  private boolean evaluateTests(Rule rule, ArrayList<String> tests) {
    if (tests.size() == 0)
      return true;
    for (String test : tests) {
      // lines already trimed
      if (test.startsWith("?")) {
        // inequality constraint
        if (!evaluateInEqConstraint(rule, test))
          return false;
      } else {
        // general predicate
        if (!evaluatePredicate(rule, test))
          return false;
      }
    }
    // all tests syntactically correct
    return true;
  }

  /**
   * inequality constraints are of the form
   * ?var != ?var2
   * ?var != uri
   * ?var != atom
   * note the space around "!="
   */
  private boolean evaluateInEqConstraint(Rule rule, String line) {
    StringTokenizer st = new StringTokenizer(line);
    // ineq constraint should consist of three tokens
    if (st.countTokens() != 3)
      return tupleStore.sayItLoud(rule.name + ": incorrect ineq constraint (less/more than 3 tokens)");
    // check whether ineq vars have all been mentioned in the ante/cons of the rule
    String token = st.nextToken();
    if (this.varToId.containsKey(token))
      rule.inEqConstraints.add(this.varToId.get(token));
    else
      return tupleStore.sayItLoud(rule.name + ": incorrect ineq constraint (left-side variable does not appear on the LHS of the rule)");
    st.nextToken();  // skip "!="
    token = st.nextToken();
    if (RuleStore.isVariable(token)) {
      if (this.varToId.containsKey(token))
        rule.inEqConstraints.add(this.varToId.get(token));
      else
        return tupleStore.sayItLoud(rule.name + ": incorrect ineq constraint (right-side variable does not appear on the LHS of the rule)");
    } else {
      token = parseUriOrAtom(token);
      if (token == null)
        return tupleStore.sayItLoud(rule.name +": incorrect ineq constraint (right-side value is neither a variable, a URI, nor an XSD atom");
      if (!this.tupleStore.isConstant(token))
        logger.debug("{}: {} not in initial fact base ", this.lineNo, token);
        int id = this.tupleStore.putObject(token);
        rule.inEqConstraints.add(id);
    }
    return true;
  }

  /**
   * parses a URI or an XSD atom and returns its cannonical form;
   * note: blank nodes are NOT allowed to be directly specified, as they are anonymous
   * individuals having no real name!
   *
   * @return null iff arg is neither a URI nor an XSD atom
   */
  private String parseUriOrAtom(String arg) {
    // I "borrowed" this code from TupleStore.readTuples()
    StringTokenizer st = new StringTokenizer(arg, " <>_\"\\", true);
    String token = st.nextToken();
    if (token.equals("<"))
      return this.tupleStore.parseURI(st, new ArrayList<String>());
    else if (token.equals("\""))
      return this.tupleStore.parseAtom(st, new ArrayList<String>());
    else
      return null;
  }

  /**
   * parses complex relational variable names and updates the corresponding mappings;
   * note: the string tokenizer is already freed from the "??(" prefix of a complex
   * relational variable name, such as "??(subj obj)"
   * NOTE: no more than 9 variable names should be involved in a complex relational variable
   */
  private boolean parseComplexVariable(String prefix, StringTokenizer st, ArrayList<Integer> args, String rulename) {
    String token;
    boolean isClosed = false;
    boolean moreThanZero = false;
    ArrayList<Integer> varids = new ArrayList<Integer>();
    // check whether prefix ends in a variable -- this is usually the case, e.g., "??(subj obj)", but not "??( subj obj )"
    if (!prefix.endsWith("(")) {
      prefix = "?" + prefix.substring(3);  // get rid of "??(" with which the prefix definitely starts
      // some code duplication
      if (this.varToId.containsKey(prefix)) {
        varids.add(this.varToId.get(prefix));
        moreThanZero = true;
      } else
        return tupleStore.sayItLoud(rulename+ ": incorrect predicate call (unknown LHS variable name in complex relational variable)");
    }
    // now move over the rest of the complex var pattern
    while (st.hasMoreTokens()) {
      token = st.nextToken();
      if (token.equals(" "))
        continue;
      if (token.equals(")")) {
        isClosed = true;
        break;
      }
      // token is a potential variable name wo/ the '?'; check whether there is a ?var for each complex var element
      token = "?" + token;
      if (this.varToId.containsKey(token)) {
        varids.add(this.varToId.get(token));
        moreThanZero = true;
      } else
        return tupleStore.sayItLoud(rulename + ": incorrect predicate call (unknown LHS variable name in complex relational variable)");
    }
    if (!isClosed)
      return tupleStore.sayItLoud(rulename + ": incorrect predicate call (complex relational variable is not a closed expression)");
    if (!moreThanZero)
      return tupleStore.sayItLoud(rulename + ": incorrect predicate call (complex relational variable is empty)");
    if (varids.size() > 9)
      return tupleStore.sayItLoud(rulename + ": incorrect predicate call (complex relational variable consists of too many names)");
    // syntactically and semantically well-formed complex relational variable; now construct new proxy name & proxy ID
    String proxy = "??proxy";
    int proxyid = RuleStore.RELVAR_OFFSET;  // note: offset and var ids are _negative_ numbers
    int exp = 0;
    for (Integer id : varids) {
      // ids are negative; fits nicely using the minus sign as the hyphen character
      proxy = proxy + id;
      // no more than 9 vars should be involved in a complex relational var (reasonable assumption & checked above)
      // formula returns same ids for both "??var" (see below) and "??(var)" (here)
      proxyid = proxyid + (id * (int) (Math.pow(10, exp)));
      ++exp;
    }
    this.relationalVarToId.put(proxy, proxyid);
    this.proxyIdToFunctionalIds.put(proxyid, varids);
    args.add(proxyid);
    return true;
  }

  /**
   * general predicates are of the form
   * <predName> {<var> | <uri> | <atom> | "*" }^*
   * note the special form of variables for the post-HFCv6.xx version of RDL
   * <var> ::= "?"<string> | "??"<string> | "??(" <string>^{2..*} ")"
   */
  private boolean evaluatePredicate(Rule rule, String line) {
    // do NOT treat '(' as a delimiter, since this would make the
    // recognition of complex relational predicates extremely hard
    StringTokenizer st = new StringTokenizer(line, " )", true);
    // line is not empty, so there is at least a predicate name
    String predname = st.nextToken();
    // construct the fully-qualified name, using the directory path where the operators live
    predname = OperatorRegistry.OPERATOR_PATH + predname;
    // check whether there is such a functional operator/Java class with this name
    Operator op = this.tupleStore.checkAndRegisterOperator(predname);
    // now obtain potential args
    ArrayList<Integer> args = new ArrayList<Integer>();
    String token;
    while (st.hasMoreTokens()) {
      // use part of the ineq code from above
      token = st.nextToken();
      // note: delimiters are also returned bei the string tokenizer; here: check for whitespace
      if (token.equals(" "))
        continue;
      if (RuleStore.isVariable(token)) {
        // now distinguish whether we are talking about a functional or relational var
        if (RuleStore.isRelationalVariable(token)) {
          // ordinary or complex relational variable
          if (RuleStore.isComplexRelationalVariable(token)) {
            // parseComplexVariable() employs the tokenizer; probably using split() would be a better
            if (!parseComplexVariable(token, st, args, rule.name))  // token == "??(<var-name-or-empty>"
              return false;
            // positive case: all destructive work is located in parseComplexVariable() above
          } else {
            // check whether there is a ?var for each ??var
            if (this.varToId.containsKey(token.substring(1))) {
              if (!this.relationalVarToId.containsKey(token))
                // generate relational variable id from functional variable name
                this.relationalVarToId.put(token, getFunId(token) + RuleStore.RELVAR_OFFSET);
              ArrayList<Integer> singleton = new ArrayList<Integer>();
              singleton.add(this.varToId.get(token.substring(1)));
              // a non-complex relational var is its own proxy and is associated to its functional counterpart
              this.proxyIdToFunctionalIds.put(this.relationalVarToId.get(token), singleton);
              args.add(this.relationalVarToId.get(token));
            } else
              return tupleStore.sayItLoud(rule.name + ": incorrect predicate call (relational variable has no corresponding LHS functional variable)");
          }
        } else {
          if (this.varToId.containsKey(token))
            args.add(this.varToId.get(token));
          else
            return tupleStore.sayItLoud(rule.name + ": incorrect predicate call (unknown LHS variable)");
        }
      } else {
        if (token.equals("*")) {
          args.add(RuleStore.UNBOUND);
        } else {
          token = parseUriOrAtom(token);
          if (token == null)
            return tupleStore.sayItLoud(rule.name + ": incorrect predicate call (argument is neither a LHS variable, nor a URI or XSD atom)");
          if (!this.tupleStore.isConstant(token))
            logger.debug("{}: {} not in initial fact base", this.lineNo, token);
            int id = this.tupleStore.putObject(token);
            args.add(id);

        }
      }
    }
    // finally, we must check whether the relational case reduces to relational-only variables
    int relOnlyCount = 0;
    for (Integer arg : args)
      if (RuleStore.isRelationalVariable(arg))
        ++relOnlyCount;
    if (relOnlyCount > 0)
      if (relOnlyCount != args.size())
        return tupleStore.sayItLoud(rule.name + ": incorrect predicate call (mixture of relational variables and other arguments)");
    // at last add representation of predicate to the rule's tests & add the predicate prefix path here;
    // note that we need to keep the relation var ID to functional var ID in each predicate object;
    // this mapping can be allocated in the rule object -- no need to store it individually for each predicate
    rule.tests.add(new Predicate(predname, op, args, rule.relIdToFunIds, this.varToId));
    return true;
  }

  /**
   * read in all actions directly following "@action" for later evaluation
   */
  private String readActions(BufferedReader br, ArrayList<String> actions) throws IOException {
    String line;
    // @action already consumed
    while ((line = br.readLine()) != null) {
      line = line.trim();
      ++this.lineNo;
      if (line.length() == 0)
        return line;
      else
        actions.add(line);
    }
    return "";
  }

  /**
   * actions are assumed to be of the following form:
   * <var> = functionName {<var> | <uri> | <atom>}^*
   */
  private boolean evaluateActions(Rule rule, ArrayList<String> actions) {
    if (actions.size() == 0)
      return true;
    StringTokenizer st;
    int result;
    String name, token;
    ArrayList<Integer> args;
    //Function function;
    for (String action : actions) {
      st = new StringTokenizer(action);
      token = st.nextToken();
      args = new ArrayList<Integer>();
      // first token (the binder) must be a variable
      if (RuleStore.isVariable(token)) {
        if (this.varToId.containsKey(token))
          result = this.varToId.get(token);
        else
          return tupleStore.sayItLoud(rule.name + ": incorrect action (unknown RHS binder variable "+ token +")");
      } else {
        return tupleStore.sayItLoud(rule.name + ": incorrect action (no RHS binder variable)");
      }
      // next token must be '='
      if (!st.nextToken().equals("="))
        return tupleStore.sayItLoud(rule.name + ": incorrect action (missing '=' sign)");
      // next token is assumed to be the function name (= name of a Java class; no syntax checking)
      name = st.nextToken();
      // finally zero or more args, either variables, URIs, or XSD atoms
      while (st.hasMoreTokens()) {
        token = st.nextToken();
        if (RuleStore.isVariable(token)) {
          if (this.varToId.containsKey(token))
            args.add(this.varToId.get(token));
          else
            return tupleStore.sayItLoud(rule.name + ": incorrect action (unknown argument variable)");
        } else {
          token = parseUriOrAtom(token);
          if (token == null)
            return tupleStore.sayItLoud(rule.name +": incorrect action (argument is neither a variable, nor a URI or XSD atom)");
          if (!this.tupleStore.isConstant(token))
            logger.debug("{}: {} not in initial fact base", this.lineNo, token);
            int id = this.tupleStore.putObject(token);
            args.add(id);
        }
      }
      // store function representation inside the rule object
      rule.actions.add(new Function(result, name, args));
    }
    // true = well-defined action definitions
    return true;
  }

  /**
   * in case anteOK == false, the rule reader has NOT seen the LHS/RHS rule separator
   */
  private boolean checkRuleSeparator(Rule rule, boolean anteOK) {
    if (rule != null)
      if (!anteOK) {
        tupleStore.sayItLoud(rule.name + ": LHS/RHS rule separator is missing");
      }
    return anteOK;
  }

  /**
   * assigns a local Table object to each LHS clause of a rule
   * structural equivalent clauses, e.g.,
   * <?s, a, ?t, b> or <?s, a, ?u, b>;
   * however, <?s, a, ?s, b> should be treated differently, since
   * this pattern enforces identity at first and third position;
   * <p>
   * if a pattern variable is furthermore a don't care variable,
   * the corresponding pattern should not be identified with
   * structural identical patterns not containing don't cares!!!
   * <p>
   * across different rules, we will share the same local binding
   * and delta table, even though the Table container are different;
   * equivalence is represented by encoding a sequence of constants
   * and variable encodings
   *
   * @see de.dfki.lt.hfc.Table
   */
  private void createLocalTables(Rule rule) {
    rule.localQueryBindings = new Table[rule.ante.length];
    rule.keys = new int[rule.ante.length][];
    for (int j = 0; j < rule.ante.length; j++) {
      int[] clause = rule.ante[j];
      int[] key = new int[clause.length];
      HashSet<Integer> properVariables = new HashSet<Integer>();
      HashSet<Integer> dontCareVariables = new HashSet<Integer>();
      HashMap<Integer, ArrayList<Integer>> nameToPos = new HashMap<Integer, ArrayList<Integer>>();
      HashMap<Integer, Integer> posToName = new HashMap<Integer, Integer>();
      HashMap<Integer, Integer> varToOcc = new HashMap<Integer, Integer>();
      ArrayList<Integer> relevantPositions = new ArrayList<Integer>();
      int occ = 0;
      int dupl = 0;
      for (int i = 0; i < clause.length; i++) {
        if (RuleStore.isVariable(clause[i])) {
          // is the variable a don't care variable
          if (rule.dontCareVariables.contains(clause[i])) {
            dontCareVariables.add(clause[i]);
            key[i] = 0;  // dont-cares = 0
            // do NOT record don't cares (as we do for atoms)
            continue;
          }
          properVariables.add(clause[i]);
          // relevantPositions is *SORTED* (important!)
          relevantPositions.add(i);
          // encode proper vars by occurrence
          if (varToOcc.containsKey(clause[i]))
            key[i] = varToOcc.get(clause[i]);
          else {
            key[i] = --occ;
            varToOcc.put(clause[i], occ);
          }
          // update nameToPos
          if (nameToPos.containsKey(clause[i])) {
            nameToPos.get(clause[i]).add(i);
            dupl++;
          } else {
            ArrayList<Integer> posSet = new ArrayList<Integer>();
            posSet.add(i);
            nameToPos.put(clause[i], posSet);
          }
          // update posToName
          posToName.put(i, clause[i]);
        } else
          // constants: use value directly
          key[i] = clause[i];
      }
      // check whether an equivalent clause already exists
      Proxy proxy = this.equivalentClauses.get(key);
      if (proxy == null) {
        // determine positions in clause headed by the same variables
        // (equalPositions.length == 0): no duplicate variables in clause
        int[][] equalPositions = new int[dupl][];
        int[] eqVars;
        int i = 0;
        for (ArrayList<Integer> al : nameToPos.values()) {
          if (al.size() > 1) {
            eqVars = new int[al.size()];
            for (int k = 0; k < al.size(); k++)
              eqVars[k] = al.get(k).intValue();
            equalPositions[i++] = eqVars;
          }
        }
        // determine positions of proper variables in clause
        // (properPositions.length == 0): no proper variables in clause;
        // duplicate proper variables only occur once in properPositions, whereas
        // relevantPositions mentions every occurrence!
        int[] properPositions = new int[properVariables.size()];
        i = 0;
        for (Integer p : properVariables) {
          // choose one occurence (which is the first, due to the use of add())
          properPositions[i++] = nameToPos.get(p).get(0);
        }
        // sub-arrays in equalPositions are sorted, but not properPositions
        Arrays.sort(properPositions);
        // need relevant positions as array
        int[] rp = new int[relevantPositions.size()];
        for (int p = 0; p < relevantPositions.size(); p++)
          rp[p] = relevantPositions.get(p);
        proxy = new Proxy(new THashSet<int[]>(),  // table
                null,                   // old
                null,                   // delta
                equalPositions,
                properPositions,
                rp,
                new TIntArrayHashingStrategy(properPositions));
        this.equivalentClauses.put(key, proxy);
      }
      // next name-to-pos mapping is needed during global clause matching using joins
      TreeMap<Integer, Integer> nameToPosProper = new TreeMap<Integer, Integer>();
      for (Integer pos : nameToPos.keySet()) {
        // take first element
        nameToPosProper.put(pos, nameToPos.get(pos).get(0));
      }
      rule.localQueryBindings[j] = new Table(properVariables, dontCareVariables,
              nameToPos, nameToPosProper, posToName,
              proxy);
      rule.keys[j] = key;
    }
  }

  /**
   * some of the checks that are performed during a rule file is read in:
   * + check that antecedent and consequent consist of at least one tuple
   * + output warning for unused variables (introduced on LHS, not used
   * on RHS) -- encode don't care variables
   * + output warning for unbound variables (not introduced on LHS, used
   * on RHS) -- encode introduction of a fresh new individual
   * + output warning for URIs & XSD atoms that are not
   * mentioned in the initial fact base
   *
   * @throws IOException
   */
  protected ArrayList<Rule> readRules(BufferedReader br) throws IOException {
    String line, token;
    StringTokenizer st;
    int noOfRules = 0;
    ArrayList<String> tuple = new ArrayList<String>();
    ArrayList<String> tests = new ArrayList<String>();
    ArrayList<String> actions = new ArrayList<String>();
    boolean eol = true;
    boolean anteOK = false;
    boolean isNew = true;
    int[] ituple;
    ArrayList<int[]> tlist = new ArrayList<int[]>();
    Rule rule = null;
    boolean parseLhs = true;
    while ((line = br.readLine()) != null) {
      // get rid of spaces at begin and end of line
      line = line.trim();
      ++this.lineNo;
      // skip comments
      if (line.startsWith("#"))
        continue;
      // rules MUST start with a rule name, indicated by a leading '$'
      if (line.startsWith("$")) {
        isNew = true;
        // check whether a rule of this _name_ already exists
        if (this.allRuleNames.contains(line)) {
          logger.debug("rule with same name on line {} already exists; skipping definition ...", line);
          isNew = false;
        } else
          this.allRuleNames.add(line);
        // create a new rule object, setting rule store state to this
        rule = new Rule();
        // used below to see whether we are parsing the antecedent or the consequent section of a rule
        parseLhs = true;
        rule.setName(line);
        rule.setRuleStore(this);
        rule.setTupleStore(this.tupleStore);
        this.varToId = new HashMap<String, Integer>();  // new for each rule and stored in Predicate instances
        this.relationalVarToId.clear();
        this.proxyIdToFunctionalIds = new HashMap<Integer, ArrayList<Integer>>();  // new for EACH individual rule !!
        rule.relIdToFunIds = this.proxyIdToFunctionalIds;
        this.varCounter = -1;
        continue;
      }
      if (line.startsWith("&")) {
        st = new StringTokenizer(line);
        if (st.nextToken().toUpperCase().equals("&PRIORITY") && st.hasMoreTokens()) {
          rule.priority = Integer.parseInt(st.nextToken());
          continue;
        } else {
          tupleStore.sayItLoud(this.lineNo, ": incorrect priority description");
          break;
        }
      }
      // antecedent and consequent are separated by a line consisting of either "->", "-->, "=>", or "==>"
      if (line.startsWith("->") || line.startsWith("-->") || line.startsWith("=>") || line.startsWith("==>")) {
        // destructively extend rule instance
        parseLhs = false;
        anteOK = makeAntecedent(tlist, rule);
        tlist.clear();
        continue;
      }
      // tests concerning the LHS of a rule
      if (line.startsWith("@test")) {
        // gather tests and evaluate them later
        line = readTests(br, tests);
      }
      // actions concerning the RHS of a rule
      if (line.startsWith("@action")) {
        // gather actions and evaluate them later
        line = readActions(br, actions);
      }
      // empty line indicates that the definition of a rule ends here
      if (line.length() == 0) {
        // destructively extend rule and add rule to the set of all rules
        if (checkRuleSeparator(rule, anteOK) &&
                evaluateTests(rule, tests) &&
                evaluateActions(rule, actions) &&
                // evaluate actions before consequent, since new binder vars are introduced
                makeConsequent(tlist, rule)) {
          // now potentially invoke a clause reordering
          reorderAntecedent(rule);
          // create the local tables to speed up initial LHS matching
          createLocalTables(rule);
          // determine which clauses "go together" during global LHS match
          computeAmalgamation(rule);
          // and finally add rule to set of all rules
          if (isNew) {
            this.allRules.add(rule);
            ++noOfRules;
          }
        }
        tlist.clear();
        tests.clear();
        actions.clear();
        rule = null;
        anteOK = false;
        continue;
      }
      // now generate a string tuple representation for each tuple line;
      // note: blank nodes are not allowed in rule tuples
      st = new StringTokenizer(line, " ?<>\"\\", true);
      tuple.clear();
      // iterate over the tokens of a rule tuple
      while (st.hasMoreTokens()) {
        token = st.nextToken();
        if (token.equals("?"))
          TupleStore.parseVariable(st, tuple);
        else if (token.equals("<"))
          this.tupleStore.parseURI(st, tuple);
        else if (token.equals("\""))
          this.tupleStore.parseAtom(st, tuple); 
        else if (token.equals(" "))  // keep on parsing ...
          continue;
          // something has gone wrong during reading of ante/cons tuple
        else {
          eol = tupleStore.sayItLoud(this.lineNo, ": tuple misspelled " + line);
          break;
        }
      }
      if (eol) {
        if (tupleStore.equivalenceClassReduction) {
          // this is the place where we need to look for equivalence relation instances
          // and where we potentially need to replace individuals by their proxies
          ituple = makeTuple(tuple);  // no worry to think about short/long namespaces
          if (this.tupleStore.isEquivalenceRelation(ituple)) {
            // check whether ituple is part of antecedent or consequent section
            if (parseLhs) {
              // generate a test and add it to list of tests
              generateTest(tuple, ituple[this.tupleStore.predicatePosition], tests, rule.name);
              logger.debug("  " + rule.name + ": equivalence reduction enforces new LHS test");
            } else {
              // generate a binder var and an action;
              // then add reflexive triple (?var eqrel ?var) to the consequent of the rule
              String varname = generateNewVariableName();
              generateAction(varname, tuple, ituple[this.tupleStore.predicatePosition], actions, rule.name);
              logger.debug("  " + rule.name + ": equivalence reduction enforces new RHS action");
              final ArrayList<String> eqTuple = new ArrayList<String>();
              // I assume the following tuple representation: EITHER [front] s p o [back+] OR [front] p s o [back+]
              if (this.tupleStore.objectPosition != 2)
                eqTuple.add(tuple.get(0));  // only one front element
              eqTuple.add(varname);
              eqTuple.add(this.tupleStore.idToJavaObject.get(ituple[this.tupleStore.predicatePosition]).toString());
              eqTuple.add(varname);
              // same for back elements
              for (int i = this.tupleStore.objectPosition + 1; i < tuple.size(); i++)
                eqTuple.add(tuple.get(i));
              tlist.add(makeTuple(eqTuple));
            }
          } else {
            // _destructively_ replace URI by proxy URI
            for (int i = 0; i < ituple.length; i++) {
              // in principle, only URIs need to be replaced by a proxy
              if (this.tupleStore.uriToProxy.containsKey(ituple[i]))
                ituple[i] = this.tupleStore.uriToProxy.get(ituple[i]);
            }
            tlist.add(ituple);
          }
        } else {
          // no equivalence class reduction computed
          tlist.add(makeTuple(tuple));
        }
      } else
        eol = true;
    }
    // in case that the file directly ends at the very last non-whitespace
    // character or directly in the following line, the last rule definition
    // has not finished -- OK, this is some code reduplication
    if (rule != null) {
      if (checkRuleSeparator(rule, anteOK) &&
              evaluateTests(rule, tests) &&
              evaluateActions(rule, actions) &&
              makeConsequent(tlist, rule)) {
        reorderAntecedent(rule);
        createLocalTables(rule);
        computeAmalgamation(rule);
        if (isNew) {
          this.allRules.add(rule);
          ++noOfRules;
        }
      }
    }

    logger.debug("read {} proper rules", noOfRules);
    logger.debug("found {} unique rules", this.allRules.size());
    
    // sort rule list according to priority value
    Collections.sort(this.allRules, this.ruleComparator);
    return this.allRules;
  }

  /**
   * @see TupleStore.cleanUpTupleStore()
   * @see TupleStore.isEquivalenceRelation()
   * @see generateAction()
   */
  private void generateTest(ArrayList<String> tuple, int eqrel, ArrayList<String> tests, String rulename) {
    StringBuilder sb = new StringBuilder();
    // can we dispatch better?
    // YES: map (for more choices), but not now!
    switch (eqrel) {
      case NamespaceManager.OWL_SAMEAS_ID:
        sb.append("SameAsTest ");
        break;
      case NamespaceManager.OWL_EQUIVALENTCLASS_ID:
        sb.append("EquivalentClassTest ");
        break;
      case NamespaceManager.OWL_EQUIVALENTPROPERTY_ID:
        sb.append("EquivalentPropertyTest ");
        break;
      default:
        throw new RuntimeException(
                "\nunknown equivalence relation in LHS of rule " + rulename);
    }
    // make subject and object of original tuple arguments of the test;
    // equivalence relation patterns are _always_ triples
    sb.append(tuple.get(this.tupleStore.subjectPosition));
    sb.append(" ");
    sb.append(tuple.get(this.tupleStore.objectPosition));
    tests.add(sb.toString());
  }

  /**
   * @see TupleStore.cleanUpTupleStore()
   * @see TupleStore.isEquivalenceRelation()
   * @see generateTest()
   */
  private void generateAction(String varname, ArrayList<String> tuple, int eqrel, ArrayList<String> actions, String rulename) {
    StringBuilder sb = new StringBuilder();
    // generate a brand new variable name for the RHS
    sb.append(varname);
    sb.append(" = ");
    switch (eqrel) {
      case NamespaceManager.OWL_SAMEAS_ID:
        sb.append("SameAsAction ");
        break;
      case NamespaceManager.OWL_EQUIVALENTCLASS_ID:
        sb.append("EquivalentClassAction ");
        break;
      case NamespaceManager.OWL_EQUIVALENTPROPERTY_ID:
        sb.append("EquivalentPropertyAction ");
        break;
      default:
        throw new RuntimeException(
                "\nunknown equivalence relation in RHS of rule " + rulename);
    }
    sb.append(tuple.get(this.tupleStore.subjectPosition));
    sb.append(" ");
    sb.append(tuple.get(this.tupleStore.objectPosition));
    actions.add(sb.toString());
  }

  /**
   *
   */
  private String generateNewVariableName() {
    return ("?__actionBinder" + this.varCounter--);
  }

  /**
   * a simple version that writes all rules from the rule store to a file using
   * the external representation
   */
  public void writeRules(String filename) {
    logger.debug("writing rules to {} ...", filename);
    try {
      PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
      for (Rule rule : this.allRules) {
        pw.println(rule.toString(this.tupleStore));
      }
      pw.flush();
      pw.close();
    } catch (IOException e) {
      logger.error("Error while writing rules to {}", filename);
      throw new RuntimeException("FATAL ERROR");
    }
  }

  /**
   * returns a copy of the rule store that can be used to generate "choice points,
   * e.g., during reasoning, as is used by ForwardChainer
   *
   * @see de.dfki.lt.hfc.ForwardChainer.copyForwardChainer()
   */
  public RuleStore copyRuleStore(TupleStore store) {
    RuleStore copy = new RuleStore(store);
    // copy this.equivalentClauses: keys can be taken over, but the values needed to be nearly deep copied
    copy.equivalentClauses = new TCustomHashMap<int[], Proxy>(TupleStore.DEFAULT_HASHING_STRATEGY, this.equivalentClauses);
    for (int[] key : copy.equivalentClauses.keySet()) {
      // use special Proxy copy constructor
      copy.equivalentClauses.put(key, new Proxy(this.equivalentClauses.get(key)));
    }
    // copy this.allRules
    copy.allRules = new ArrayList<Rule>(this.allRules);
    for (int i = 0; i < copy.allRules.size(); i++) {
      // use special Rule copy constructor
      copy.allRules.set(i, new Rule(this.allRules.get(i), store, copy));
    }
    // finished!
    return copy;
  }

}
