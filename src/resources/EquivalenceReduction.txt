
equivalence relation R
======================
  * R is reflexive
	* R is symmetric
	* R is transitive
	
	
at the moment, the implementation addresses the three
equivalence relations for TBox, RBox, and ABox:
  * owl:equivalentClass
	* owl:equivalentProperty
	* owl:sameAs
	

generalize this to arbitrary properties by adding new OWL property
characteristics owl:equivalenceRelation ?!?
use this (later) to determine the type id of the above (and other)
equivalence relations


it must be guaranteed that the tuple store does NOT contain
triples (or more general tuples) having one of those relations
in predicate position;
instead, such relation instances (and their effects) are represented
by the below two tables


introduce constant that specify the predicate position


this must be achieved at several places during processing:
  * when reading in a tuple file
	* when instantiating RHS rule patterns


in addition, a method must be available that cleans up/normalizes
a tuple store according to the equivalence relation instances
available so far;
this method not only might be applied before closure computation or
a later tuple upload, but also when equivalence relation instances
are generated by RHS patters


question: when do we apply normalization (e.g., after each closure
iteration step?)


clean-up not only manipulate the
  * tuple store,
but also the
  * index
and the
  * local rule field of each rule

	
mark rules that generate equivalence relation instances -- only such
rules need to be checked


example (read in content of a file):
====================================
  ...
  a rdf:type X
	...
	b rdf:type Y
	...
	a owl:sameAs b
	...
	
enter "a rdf:type X" and "b rdf:type Y";
do NOT enter "a owl:sameAs b", but record this (see below);
later clean up tuple store by replacing all occurences of a and b
by their unique proxy.
	
furthermore, 	
	* when reading in a rule file, or
	* when submitting a query
it might happen that URIs need be replaced by their proxy;
for queries, this can be achieved at the time when the query is
submitted;
in case of rules, this can NOT be achieved when a rule is read in,
since equivalence relation instances might be generated at every
time (so that rules always need to be readjusted)


LHS with Equivalence Relation Instance
======================================
  rewrite such a rule when reading in by adding a further predicate
	to the test section;  example:
	
	  ?x <owl:sameAs> ?y
		?x <owl:differentFrom> ?y
		->
		?x <rdf:type> <owl:Nothing>
		?y <rdf:type> <owl:Nothing>
  
	replace by
	
		?x <owl:differentFrom> ?y
		->
		?x <rdf:type> <owl:Nothing>
		?y <rdf:type> <owl:Nothing>
		@test SameAsTest ?x ?y
	
	
RHS with Equivalence Relation Instance
======================================
  add a call of a (void) method to the action section (reader must be
	modified);  example:

	  ?p <<rdf:type> <owl:FunctionalProperty>
		?p <rdf:type> <owl:ObjectProperty>
    ?x ?p ?y
    ?x ?p ?z
    ->
    ?y <owl:sameAs> ?z
    @test
    ?y != ?z

	either replace by

	  ?p <<rdf:type> <owl:FunctionalProperty>
		?p <rdf:type> <owl:ObjectProperty>
    ?x ?p ?y
    ?x ?p ?z
    ->
								// empty RHS
    @test
    ?y != ?z
		@action     // action that does not return a value
		SameAsAction ?y ?z
		
  or replace by
	  
		?p <<rdf:type> <owl:FunctionalProperty>
		?p <rdf:type> <owl:ObjectProperty>
    ?x ?p ?y
    ?x ?p ?z
    ->
		?saa        // return a 1-tuple
    @test
    ?y != ?z
		@action     // SameAsAction _always_ returns the same value
		?saa = SameAsAction ?y ?z


certain rules need to be removed from the OWL-Horst file default.rdl
====================================================================
  * $owl_sameAsCopySubj
    ?x <owl:sameAs> ?y
    ?x ?p ?z
    ->
    ?y ?p ?z
    @test
    ?x != ?y
  * $owl_sameAsCopyObj
    ?x <owl:sameAs> ?y
    ?z ?p ?x
    ->
    ?z ?p ?y
    @test
    ?x != ?y
  * ?p <owl:equivalentProperty> ?q
    ?x ?p ?y
    ->
    ?x ?q ?y
    @test
    ?p != ?q
		
DONE: file erdefault.rdl


certain axiomatic triples need to be removed from the file default.nt
=====================================================================
  * <owl:sameAs> <rdf:type> <owl:TransitiveProperty> .
  * <owl:sameAs> <rdf:type> <owl:SymmetricProperty> .
  * <owl:equivalentClass> <rdf:type> <owl:TransitiveProperty> .
  * <owl:equivalentClass> <rdf:type> <owl:SymmetricProperty> .
  * <owl:equivalentProperty> <rdf:type> <owl:TransitiveProperty> .
  * <owl:equivalentProperty> <rdf:type> <owl:SymmetricProperty> .
	
DONE: file erdefault.nt


three cases to distinguish (DONE)
==========================
  (1) left and right are _not_ keys in uriToProxy
	(2) left xor right is a key in uriToProxy
	(3) left and right are keys in uriToProxy


two mappings (DONE)
============
  * uriToProxy  : int -> int
	* proxyToUris : int -> List(int)


do not generate new proxies, but instead chose one of the URI
arguments for case (1), or the already existing proxy for case
(2), or make one of the two proxies _the_ new proxy and forget
about the second (followed by manipulations of the two tables)


example: let R be an equivalence relation
=========================================
  (1) a R b (case 1)
	    a -> a
			b -> a
			a -> [a, b]
			
	(2) c R b (case 2)
	    a -> a
			b -> a
			c -> a
			a -> [a, b, c]
	
	(3) x R y (case 1)
	    a -> a
			b -> a
			c -> a
			x -> x
			y -> x
			a -> [a, b, c]
			x -> [x, y]
	
	(4) a R y (case 3: merge _different_ proxies)
	    a -> a
			b -> a
			c -> a
			x -> a
			y -> a
			a -> [a, b, c, x, y]
	
	(5) b R y (case 3: _identical_ proxies -- nothing to do!)
	    a -> a
			b -> a
			c -> a
			x -> a
			y -> a
			a -> [a, b, c, x, y]
	
	
further issues
==============

  * implement union-find data structure (DONE)
  * adapt "copy ABox" functionality (DONE)
	* method to fully expand tuple for
	    * full query _result_ expansion
			* storing the tuple store in N-Triple format
			    * also need to reconstruct the equivalence relation tuples
  * adapt fast-load format
	* implement tests: SameAsTest, EquivalentClassTest, EquivalentPropertyTest (DONE)
	* implement actions: SameAsAction, EquivalentClassAction, EquivalentPropertyAction (DONE)
	
	
	
METHODS & FIELDS IN CLASSES
===========================

Namespace: UNBOUND_ID
           OWL_SAMEAS_ID
					 EQUIVALENT_CLASS_ID
					 EQUIVALENT_PROPERTY_ID
					 
TupleStore: equivalenceClassReduction
            SUBJECT_POSITION
            PREDICATE_POSITION
						OBJECT_POSITION
						uriToProxy
						proxyToUris
						addEquivalentElements()
						isEquivalenceRelation()
						cleanUpTupleStore()
						readTuples() adjusted
						copyTupleStore() adjusted
						
SameAsTest: apply()

SameAsAction: apply()

EquivalentClassTest: apply()

EquivalentClassAction: apply()

EquivalentPropertyTest: apply()

EquivalentPropertyAction: apply()
