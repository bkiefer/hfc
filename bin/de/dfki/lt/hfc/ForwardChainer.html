<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_60) on Fri Aug 29 12:01:29 CEST 2014 -->
<title>ForwardChainer</title>
<meta name="date" content="2014-08-29">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ForwardChainer";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../de/dfki/lt/hfc/Configuration.html" title="class in de.dfki.lt.hfc"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../de/dfki/lt/hfc/Function.html" title="class in de.dfki.lt.hfc"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?de/dfki/lt/hfc/ForwardChainer.html" target="_top">Frames</a></li>
<li><a href="ForwardChainer.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">de.dfki.lt.hfc</div>
<h2 title="Class ForwardChainer" class="title">Class ForwardChainer</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>de.dfki.lt.hfc.ForwardChainer</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="strong">ForwardChainer</span>
extends java.lang.Object</pre>
<div class="block">generates a tuple store, a rule store, and a namespace object in order to
 compute the deductive closure (the fixpoint) of the derivation relation '->'
 (and '=>', later!) w.r.t. a set of rules and a set of tuples;

 NOTE: depending on</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JDK 1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><code>and</code>, 
<code>it might be the case that the closure computation needs to be called
       again, since the cleanup phase performed afterwards could lead to the
       possibility that passive rules become active again !!</code></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#blankCounter">blankCounter</a></strong></code>
<div class="block">used to generate unique blank node names</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#blankNodePrefix">blankNodePrefix</a></strong></code>
<div class="block">used to generate unique blank node names for _this_ forward chainer</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#cleanUpRepository">cleanUpRepository</a></strong></code>
<div class="block">this Boolean flag is only considered in the closure computation, when the
 equivalence class reduction is turned on in the tuple store</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../../de/dfki/lt/hfc/TIntArrayHashingStrategy.html" title="class in de.dfki.lt.hfc">TIntArrayHashingStrategy</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#DEFAULT_HASHING_STRATEGY">DEFAULT_HASHING_STRATEGY</a></strong></code>
<div class="block">the default hashing and equals strategy for tuples from the rule output set of the current
 iteration: take ALL positions of a tuple into account</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private java.util.concurrent.CountDownLatch</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#doneSignal">doneSignal</a></strong></code>
<div class="block">needed to to start a new iteration</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#exitOnError">exitOnError</a></strong></code>
<div class="block">a constant that controls whether the system is terminated in case an invalid
 tuple is read in (exit code = 1);
 a similar variable exists in class RuleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#gc">gc</a></strong></code>
<div class="block">call the garbage collector after each iteration step</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#generationCounter">generationCounter</a></strong></code>
<div class="block">generation counter is incremented during each iteration, independent of how
 many times computeClosure() is called;
 thus a new call to computeClosure() does NOT reset the counter to 0 (zero),
 but instead increments it further by 1;
 is used during local clause querying</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#INFO">INFO</a></strong></code>
<div class="block">HFC info string</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#namespace">namespace</a></strong></code>
<div class="block">the namespace object, whose namespaces are used in rules and tuples</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#noOfAtoms">noOfAtoms</a></strong></code>
<div class="block">default settings that might speed up the forward chainer (actually the tuple store)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#noOfCores">noOfCores</a></strong></code>
<div class="block">specifies the number of parallel executed rule threads;
 do not specify a number larger than the sum of all cores of your computer</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#noOfIterations">noOfIterations</a></strong></code>
<div class="block">tells the forward chainer how many top-level loops should be performed
 during the computation of the deductive closure;
 Integer.MAX_VALUE indicates that the fixpoint iteration is not restricted by
 any number</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#noOfTasks">noOfTasks</a></strong></code>
<div class="block">specifies the number of tasks (= #rules) that are executed within a single
 iteration; will be assigned a value when constructor is executed</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#noOfTuples">noOfTuples</a></strong></code>
<div class="block">default settings that might speed up the forward chainer (actually the tuple store)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ruleStore">ruleStore</a></strong></code>
<div class="block">a pointer to the rule store for this forward chainer</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private java.util.concurrent.ExecutorService</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#threadPool">threadPool</a></strong></code>
<div class="block">container to gather the rule threads</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#tupleStore">tupleStore</a></strong></code>
<div class="block">a pointer to the tuple store for this forward chainer</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#verbose">verbose</a></strong></code>
<div class="block">a constant that controls whether a warning is printed in case an invalid
 tuple is read in;
 a similar variable exists in class RuleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#VERSION">VERSION</a></strong></code>
<div class="block">HFC version number string</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private </code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer()">ForwardChainer</a></strong>()</code>
<div class="block">prints a welcome message to standard out</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private </code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(int,%20boolean)">ForwardChainer</a></strong>(int&nbsp;noOfCores,
              boolean&nbsp;verbose)</code>
<div class="block">used by copyForwardChainer()</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(int,%20boolean,%20boolean,%20boolean,%20int,%20int,%20int,%20int,%20java.lang.String,%20java.lang.String,%20java.lang.String)">ForwardChainer</a></strong>(int&nbsp;noOfCores,
              boolean&nbsp;verbose,
              boolean&nbsp;rdfCheck,
              boolean&nbsp;eqReduction,
              int&nbsp;minNoOfArgs,
              int&nbsp;maxNoOfArgs,
              int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</code>
<div class="block">more options that will also affect namespace, tuple store, and rule store</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(int,%20boolean,%20int,%20int,%20de.dfki.lt.hfc.Namespace,%20de.dfki.lt.hfc.TupleStore,%20de.dfki.lt.hfc.RuleStore)">ForwardChainer</a></strong>(int&nbsp;noOfCores,
              boolean&nbsp;verbose,
              int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
              <a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a>&nbsp;tupleStore,
              <a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a>&nbsp;ruleStore)</code>
<div class="block">slightly less options as before, but namespace, tuple store, and rule store have already
 been created</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(int,%20int,%20java.lang.String,%20java.lang.String)">ForwardChainer</a></strong>(int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile)</code>
<div class="block">generates a new forward chainer with the default namespace for XSD, RDF, RDFS, and OWL;
 noOfAtoms and noOfTuples are important parameters that affects the performance of the
 tuple store used by the forward chainer</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(int,%20int,%20java.lang.String,%20java.lang.String,%20java.lang.String)">ForwardChainer</a></strong>(int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</code>
<div class="block">this version allows to explicitly define the namespace</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(de.dfki.lt.hfc.Namespace,%20de.dfki.lt.hfc.TupleStore,%20de.dfki.lt.hfc.RuleStore)">ForwardChainer</a></strong>(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
              <a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a>&nbsp;tupleStore,
              <a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a>&nbsp;ruleStore)</code>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(java.lang.String,%20java.lang.String)">ForwardChainer</a></strong>(java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile)</code>
<div class="block">generates a new forward chainer with the default namespace for XSD, RDF, RDFS, and OWL</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#ForwardChainer(java.lang.String,%20java.lang.String,%20java.lang.String)">ForwardChainer</a></strong>(java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</code>
<div class="block">this version allows to explicitly define the namespace</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#addTuples(java.util.Collection)">addTuples</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">add tuples, represented as int[], to the set of all tuples;
 if tuple deletion is enabled in the forward chainer, the tuples from the set are
 assigned the actual generation TupleStore.generation</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#addTuplesToRepository(java.util.Collection)">addTuplesToRepository</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">transaction 1: addTuplesToRepository()
 adds a collection of tuples to the repository;
 this quasi-synchronized method obtains a lock on this.tupleStore;
 note that the generation counter from TupleStore is incremented by 2 _before_
 the tuples are added in order to distinguish the tuples envolved in this transactions
 from `ordinary' tuples that are `only' uploaded;
 note further that this transaction does NOT compute the deductive closure of the repository</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#applyTests(de.dfki.lt.hfc.Rule)">applyTests</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">in order to speed up rule execution, it is important to check whether the two
 variables in an in-eq constraint belong to a same rule cluster from the rule's
 cluster list;
 if so, the corresponding binding table can be "reduced" using the in-eq constraints;
 if not, the in-eq need to be considered later before/during RHS instantiation;
 examples
   + 1 LHS clause cluster:  ?x p ?y, ?y p ?z, ?x != ?y, ?y != ?z -> ?x p ?z
     do NOT iterate _twice_ over the binding table to check both in-eqs
   + 2 LHS clause clusters: ?u p ?v, ?x q ?y, ?u != ?y -> ?u r ?y
     in-eq applies to RHS, but RHS in principle requires Cartesian product of
     the two independent LHS clusters
   + 2 LHS clause clusters: ?u p ?v, ?x q ?y, ?u != ?x, ?v != ?y -> ?u r ?y
     both in-eqs can not be applied directly to LHS clusters, nor RHS, but
     in-eqs rule out certain combinations for (?u, ?y) that cooccur with
     (?u, ?x) and (?v, ?y)
   + in-eqs with URIs/XSD atoms: ?s ?p ?o, ?p != <rdf:type> -> .....</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private <a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#complexJoin(de.dfki.lt.hfc.Table[],%20java.util.ArrayList,%20int,%20boolean,%20java.util.ArrayList,%20java.util.HashMap)">complexJoin</a></strong>(<a href="../../../../de/dfki/lt/hfc/Table.html" title="class in de.dfki.lt.hfc">Table</a>[]&nbsp;locbind,
           java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;cluster,
           int&nbsp;index,
           boolean&nbsp;newInfo,
           java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;joinit,
           java.util.HashMap&lt;<a href="../../../../de/dfki/lt/hfc/Pair.html" title="class in de.dfki.lt.hfc">Pair</a>,<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;memo)</code>
<div class="block">does the recursive job for executeGlobalMatch();
 recursively takes the union of the continuation of complexJoin() for both delta and old at
 a specific index for a given cluster;
 at least one of the tables must be new and of course not empty (as is the case for old
 information)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private <a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#complexProduct(de.dfki.lt.hfc.Cluster[],%20int,%20boolean,%20java.util.ArrayList)">complexProduct</a></strong>(<a href="../../../../de/dfki/lt/hfc/Cluster.html" title="class in de.dfki.lt.hfc">Cluster</a>[]&nbsp;clusters,
              int&nbsp;index,
              boolean&nbsp;newInfo,
              java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;productit)</code>
<div class="block">does the recursive job for prepareInstantiation();
 recursively takes the union of the continuation of complexProduct() for both delta and old
 of each cluster;
 at least one of the tables must be new and of course not empty (as is the case for old
 information) -- this is called "semi-naive evaluation" in logic programming</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#compress(int)">compress</a></strong>(int&nbsp;level)</code>
<div class="block">if 0, auxiliary structures in forward chainer are not compressed/deleted;
 if 1, the old/new separation for clause proxies, clusters, and mega
       clusters is deleted;
 if 2, the index structure is deleted;
 if 3, old/new structures are deleted AND the index structure is deleted</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosure()">computeClosure</a></strong>()</code>
<div class="block">the number of iterations is given by global this.noOfIterations;
 whether the repository is cleaned up is determined by ForwardChainer.cleanUpRepository
 and TupleStore.equivalenceClassReduction</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosure(int,%20boolean)">computeClosure</a></strong>(int&nbsp;noOfIterations,
              boolean&nbsp;cleanUpRepository)</code>
<div class="block">computes the deductive closure given an initial set of tuples as
 specified by TupleStore.allTuples;
 iterates until a fixpoint is computed or a predefined iteration depth
 has been reached as given by the argument</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosure(java.util.Set)">computeClosure</a></strong>(java.util.Set&lt;int[]&gt;&nbsp;newTuples)</code>
<div class="block">the number of iterations is given by field noOfIterations</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosure(java.util.Set,%20int,%20boolean)">computeClosure</a></strong>(java.util.Set&lt;int[]&gt;&nbsp;newTuples,
              int&nbsp;noOfIterations,
              boolean&nbsp;cleanUpRepository)</code>
<div class="block">calls computeClosure(int noOfIterations) again, assuming that a set of
 new tuples has been added to the tuple store;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosureFromRepository()">computeClosureFromRepository</a></strong>()</code>
<div class="block">transaction 4: computeClosureFromRepository()
 a `nullary' transaction that computes the deductive closure for the repository;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html" title="class in de.dfki.lt.hfc">ForwardChainer</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#copyForwardChainer(int,%20boolean)">copyForwardChainer</a></strong>(int&nbsp;noOfCores,
                  boolean&nbsp;verbose)</code>
<div class="block">returns a copy of the forward chainer that can be used to generate "choice points"
 during reasoning;
 tuples are taken over, but nearly everything else is copied</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteIndex()">deleteIndex</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteOldNew()">deleteOldNew</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteTuple(int[])">deleteTuple</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">deletes a tuple and _potentially_ dependent entailed tuples of specific generations from the
 tuples store, followed by a new closure computation;
 note that we need to check whether equivalence class reduction has been turned on; if so, the
 tuple needs to be replaced by its proxy!

 this strategy implements a compromise between deleting everything and setting up a full
 TMS-like structure (that would furthermore make speed-up techniques in HFC obsolete);

 use deleteTuples() below if you want to delete more than one tuple, since deleteTuples()
 calls closure computation only once at the very end of the deletion process, whereas this method
 calls it for the tuple bound to parameter tuple

 note: this method obtains a lock of this.tupleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteTuples(java.util.Collection)">deleteTuples</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">use this method if you want to delete SEVERAL tuples at once, since both this and the above method
 always call computeClosure() at the very end (expensive!), independent of the number of tuples deleted

 note: this method obtains a lock of this.tupleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteTuplesFromRepository(java.util.Collection)">deleteTuplesFromRepository</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">transaction 3: deleteTuplesFromRepository()
 deletes a collection of tuples from the repository; not only the direct tuples
 are deleted, but also the entailed tuples which solely depend on the deleted
 tuples;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#deleteTuplesRecordGenerations(java.util.Collection,%20java.util.Hashtable)">deleteTuplesRecordGenerations</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples,
                             java.util.Hashtable&lt;int[],java.lang.Integer&gt;&nbsp;mapping)</code>
<div class="block">this private method differs from deleteTuples() above in that it destructively modifies
 the tuple-to-be-deleted-TO-generation mapping as given by parameter mapping and is
 exclusively used by deleteFromRepository()</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#enableTupleDeletion()">enableTupleDeletion</a></strong>()</code>
<div class="block">enableTupleDeletion() makes use of a special field that is initialized by an empty map
 from tuples (int[]) to generations (Integer);
 this field is localized in class TupleStore, since it interacts with the equivalence
 class reduction mechanism that is also located in TupleStore;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#execute(de.dfki.lt.hfc.Rule)">execute</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">performs the matching and instantiation for each rule;
 keeps track of local information in order to speed up rule execution;
 writes generated tuples to local output field of the rule</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#executeAllRules()">executeAllRules</a></strong>()</code>
<div class="block">assigns each rule execution a single task which is added to the thread pool</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#executeGlobalMatch(de.dfki.lt.hfc.Rule)">executeGlobalMatch</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">performs a global matching over the LHS clauses;
 local tables within the LHS of this rule are joined in case they share variables;
 good example to see complex interactions:
   $owl_typeBySomeVal
         ?q <rdf:type> ?c
     ?r <owl:onProperty> ?p
     ?r <owl:someValuesFrom> ?c
     ?i ?p ?q
   ->
     ?i <rdf:type> ?r
 instead of
   (0 J 2) J (1 J 2)
 avoid second "inner" join:
   (0 J 2) J 1
 this is achieved by computing "clusters" of LHS clauses</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#executeLocalMatch(de.dfki.lt.hfc.Rule)">executeLocalMatch</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">performs a local match over the LHS clauses;
 the result of structurally equivalent clauses is shared between clauses, even
 across rules</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#init()">init</a></strong>()</code>
<div class="block">initialization code of nullary and binary constructors that is outsourced to avoid
 code reduplication</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#main(java.lang.String[])">main</a></strong>(java.lang.String[]&nbsp;args)</code>
<div class="block">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! FOR TEST PURPOSES ONLY !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#nextBlankNode()">nextBlankNode</a></strong>()</code>
<div class="block">generates a new unique blank node id (an int);
 used during forward chaining when unbounded right-hand side variables are introduced;
 it is important that the method is synchronized to exclusively lock the blank counter;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#performInstantiation(de.dfki.lt.hfc.Rule)">performInstantiation</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">the input table for RHS instantiation has already been projected to the RHS variables</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#prepareInstantiation(de.dfki.lt.hfc.Rule)">prepareInstantiation</a></strong>(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</code>
<div class="block">computes delta, new, old, etc.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#removeTuples(java.util.Collection)">removeTuples</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">remove tuples, represented as int[], from the set of all tuples;
 if tuple deletion is enabled in the forward chainer, the tuples from the set are
 removed from TupleStore.generation</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#removeTuplesFromRepository(java.util.Collection)">removeTuplesFromRepository</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</code>
<div class="block">transaction 2: removeTuplesFromRepository()
 removes a collection of tuples from the repository;
 note that the entailed tuples are NOT deleted, only the specified tuples;
 in case closure computation is never called, i.e., the repository is only used for
 querying the explicit uploaded information, use this method instead of nethod below;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#setNoOfCores(int)">setNoOfCores</a></strong>(int&nbsp;noOfCores)</code>
<div class="block">to (dynamically) change the number of processor cores at runtime, use this method</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#shutdown()">shutdown</a></strong>()</code>
<div class="block">shutdowns the thread pool and exits with value 0</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#shutdownNoExit()">shutdownNoExit</a></strong>()</code>
<div class="block">only shutdowns the thread pool, but no System.exit() is called;
 used by the XMLRPC server</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#tupleDeletionEnabled()">tupleDeletionEnabled</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#uncompressIndex()">uncompressIndex</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#uploadNamespaces(java.lang.String)">uploadNamespaces</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">uploads further namespaces stored in a file to an already established forward chainer;
 this method directly calls readNamespaces() from class Namespace</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#uploadRules(java.lang.String)">uploadRules</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">uploads further rules stored in a file to an already established forward chainer;
 the set of all rules is returned;
 NOTE: a similar method readRules() is defined in class RuleStore;
       however, uploadRules set the field noOfTasks in ForwardChainer to the proper value</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#uploadTuples(java.lang.String)">uploadTuples</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">uploads further tuples stored in a file to an already established forward chainer;
 this method directly calls readTuples() from class TupleStore;
 if tuple deletion is enabled in the forward chainer, the tuples from the file are
 assigned the actual generation TupleStore.generation</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="VERSION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>VERSION</h4>
<pre>public static final&nbsp;java.lang.String VERSION</pre>
<div class="block">HFC version number string</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../constant-values.html#de.dfki.lt.hfc.ForwardChainer.VERSION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="INFO">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INFO</h4>
<pre>public static final&nbsp;java.lang.String INFO</pre>
<div class="block">HFC info string</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../constant-values.html#de.dfki.lt.hfc.ForwardChainer.INFO">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="tupleStore">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tupleStore</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a> tupleStore</pre>
<div class="block">a pointer to the tuple store for this forward chainer</div>
</li>
</ul>
<a name="ruleStore">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ruleStore</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a> ruleStore</pre>
<div class="block">a pointer to the rule store for this forward chainer</div>
</li>
</ul>
<a name="namespace">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>namespace</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a> namespace</pre>
<div class="block">the namespace object, whose namespaces are used in rules and tuples</div>
</li>
</ul>
<a name="noOfAtoms">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noOfAtoms</h4>
<pre>protected&nbsp;int noOfAtoms</pre>
<div class="block">default settings that might speed up the forward chainer (actually the tuple store)</div>
</li>
</ul>
<a name="noOfTuples">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noOfTuples</h4>
<pre>protected&nbsp;int noOfTuples</pre>
<div class="block">default settings that might speed up the forward chainer (actually the tuple store)</div>
</li>
</ul>
<a name="DEFAULT_HASHING_STRATEGY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_HASHING_STRATEGY</h4>
<pre>protected static&nbsp;<a href="../../../../de/dfki/lt/hfc/TIntArrayHashingStrategy.html" title="class in de.dfki.lt.hfc">TIntArrayHashingStrategy</a> DEFAULT_HASHING_STRATEGY</pre>
<div class="block">the default hashing and equals strategy for tuples from the rule output set of the current
 iteration: take ALL positions of a tuple into account</div>
</li>
</ul>
<a name="noOfIterations">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noOfIterations</h4>
<pre>public&nbsp;int noOfIterations</pre>
<div class="block">tells the forward chainer how many top-level loops should be performed
 during the computation of the deductive closure;
 Integer.MAX_VALUE indicates that the fixpoint iteration is not restricted by
 any number</div>
</li>
</ul>
<a name="cleanUpRepository">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanUpRepository</h4>
<pre>public&nbsp;boolean cleanUpRepository</pre>
<div class="block">this Boolean flag is only considered in the closure computation, when the
 equivalence class reduction is turned on in the tuple store</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.equivalenceClassReduction</code>, 
<a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#computeClosure()"><code>computeClosure()</code></a></dd></dl>
</li>
</ul>
<a name="generationCounter">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generationCounter</h4>
<pre>protected&nbsp;int generationCounter</pre>
<div class="block">generation counter is incremented during each iteration, independent of how
 many times computeClosure() is called;
 thus a new call to computeClosure() does NOT reset the counter to 0 (zero),
 but instead increments it further by 1;
 is used during local clause querying</div>
</li>
</ul>
<a name="verbose">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verbose</h4>
<pre>public&nbsp;boolean verbose</pre>
<div class="block">a constant that controls whether a warning is printed in case an invalid
 tuple is read in;
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#exitOnError"><code>exitOnError</code></a></dd></dl>
</li>
</ul>
<a name="exitOnError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>exitOnError</h4>
<pre>public&nbsp;boolean exitOnError</pre>
<div class="block">a constant that controls whether the system is terminated in case an invalid
 tuple is read in (exit code = 1);
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#verbose"><code>verbose</code></a></dd></dl>
</li>
</ul>
<a name="gc">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>gc</h4>
<pre>public&nbsp;boolean gc</pre>
<div class="block">call the garbage collector after each iteration step</div>
</li>
</ul>
<a name="noOfCores">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noOfCores</h4>
<pre>public&nbsp;int noOfCores</pre>
<div class="block">specifies the number of parallel executed rule threads;
 do not specify a number larger than the sum of all cores of your computer</div>
</li>
</ul>
<a name="noOfTasks">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>noOfTasks</h4>
<pre>private&nbsp;int noOfTasks</pre>
<div class="block">specifies the number of tasks (= #rules) that are executed within a single
 iteration; will be assigned a value when constructor is executed</div>
</li>
</ul>
<a name="threadPool">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>threadPool</h4>
<pre>private&nbsp;java.util.concurrent.ExecutorService threadPool</pre>
<div class="block">container to gather the rule threads</div>
</li>
</ul>
<a name="doneSignal">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doneSignal</h4>
<pre>private&nbsp;java.util.concurrent.CountDownLatch doneSignal</pre>
<div class="block">needed to to start a new iteration</div>
</li>
</ul>
<a name="blankNodePrefix">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blankNodePrefix</h4>
<pre>private final&nbsp;java.lang.String blankNodePrefix</pre>
<div class="block">used to generate unique blank node names for _this_ forward chainer</div>
</li>
</ul>
<a name="blankCounter">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>blankCounter</h4>
<pre>private&nbsp;int blankCounter</pre>
<div class="block">used to generate unique blank node names</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="ForwardChainer()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>private&nbsp;ForwardChainer()</pre>
<div class="block">prints a welcome message to standard out</div>
</li>
</ul>
<a name="ForwardChainer(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>private&nbsp;ForwardChainer(int&nbsp;noOfCores,
              boolean&nbsp;verbose)</pre>
<div class="block">used by copyForwardChainer()</div>
</li>
</ul>
<a name="ForwardChainer(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile)</pre>
<div class="block">generates a new forward chainer with the default namespace for XSD, RDF, RDFS, and OWL</div>
</li>
</ul>
<a name="ForwardChainer(java.lang.String, java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</pre>
<div class="block">this version allows to explicitly define the namespace</div>
</li>
</ul>
<a name="ForwardChainer(int, int, java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile)</pre>
<div class="block">generates a new forward chainer with the default namespace for XSD, RDF, RDFS, and OWL;
 noOfAtoms and noOfTuples are important parameters that affects the performance of the
 tuple store used by the forward chainer</div>
</li>
</ul>
<a name="ForwardChainer(int, int, java.lang.String, java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</pre>
<div class="block">this version allows to explicitly define the namespace</div>
</li>
</ul>
<a name="ForwardChainer(de.dfki.lt.hfc.Namespace, de.dfki.lt.hfc.TupleStore, de.dfki.lt.hfc.RuleStore)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
              <a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a>&nbsp;tupleStore,
              <a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a>&nbsp;ruleStore)</pre>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</li>
</ul>
<a name="ForwardChainer(int, boolean, boolean, boolean, int, int, int, int, java.lang.String, java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(int&nbsp;noOfCores,
              boolean&nbsp;verbose,
              boolean&nbsp;rdfCheck,
              boolean&nbsp;eqReduction,
              int&nbsp;minNoOfArgs,
              int&nbsp;maxNoOfArgs,
              int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              java.lang.String&nbsp;tupleFile,
              java.lang.String&nbsp;ruleFile,
              java.lang.String&nbsp;namespaceFile)</pre>
<div class="block">more options that will also affect namespace, tuple store, and rule store</div>
</li>
</ul>
<a name="ForwardChainer(int, boolean, int, int, de.dfki.lt.hfc.Namespace, de.dfki.lt.hfc.TupleStore, de.dfki.lt.hfc.RuleStore)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ForwardChainer</h4>
<pre>public&nbsp;ForwardChainer(int&nbsp;noOfCores,
              boolean&nbsp;verbose,
              int&nbsp;noOfAtoms,
              int&nbsp;noOfTuples,
              <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
              <a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a>&nbsp;tupleStore,
              <a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc">RuleStore</a>&nbsp;ruleStore)</pre>
<div class="block">slightly less options as before, but namespace, tuple store, and rule store have already
 been created</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="init()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre>private&nbsp;void&nbsp;init()</pre>
<div class="block">initialization code of nullary and binary constructors that is outsourced to avoid
 code reduplication</div>
</li>
</ul>
<a name="setNoOfCores(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNoOfCores</h4>
<pre>public&nbsp;void&nbsp;setNoOfCores(int&nbsp;noOfCores)</pre>
<div class="block">to (dynamically) change the number of processor cores at runtime, use this method</div>
</li>
</ul>
<a name="nextBlankNode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextBlankNode</h4>
<pre>public&nbsp;int&nbsp;nextBlankNode()</pre>
<div class="block">generates a new unique blank node id (an int);
 used during forward chaining when unbounded right-hand side variables are introduced;
 it is important that the method is synchronized to exclusively lock the blank counter;</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>de.dfki.lt.hfc.ForwardChainer.blankCounter</code></dd></dl>
</li>
</ul>
<a name="executeLocalMatch(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeLocalMatch</h4>
<pre>private&nbsp;void&nbsp;executeLocalMatch(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">performs a local match over the LHS clauses;
 the result of structurally equivalent clauses is shared between clauses, even
 across rules</div>
</li>
</ul>
<a name="executeGlobalMatch(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeGlobalMatch</h4>
<pre>private&nbsp;void&nbsp;executeGlobalMatch(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">performs a global matching over the LHS clauses;
 local tables within the LHS of this rule are joined in case they share variables;
 good example to see complex interactions:
   $owl_typeBySomeVal
         ?q <rdf:type> ?c
     ?r <owl:onProperty> ?p
     ?r <owl:someValuesFrom> ?c
     ?i ?p ?q
   ->
     ?i <rdf:type> ?r
 instead of
   (0 J 2) J (1 J 2)
 avoid second "inner" join:
   (0 J 2) J 1
 this is achieved by computing "clusters" of LHS clauses</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/RuleStore.html#computeAmalgamation(de.dfki.lt.hfc.Rule)"><code>RuleStore.computeAmalgamation(de.dfki.lt.hfc.Rule)</code></a></dd></dl>
</li>
</ul>
<a name="complexJoin(de.dfki.lt.hfc.Table[], java.util.ArrayList, int, boolean, java.util.ArrayList, java.util.HashMap)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>complexJoin</h4>
<pre>private&nbsp;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&nbsp;complexJoin(<a href="../../../../de/dfki/lt/hfc/Table.html" title="class in de.dfki.lt.hfc">Table</a>[]&nbsp;locbind,
                       java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;cluster,
                       int&nbsp;index,
                       boolean&nbsp;newInfo,
                       java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;joinit,
                       java.util.HashMap&lt;<a href="../../../../de/dfki/lt/hfc/Pair.html" title="class in de.dfki.lt.hfc">Pair</a>,<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;memo)</pre>
<div class="block">does the recursive job for executeGlobalMatch();
 recursively takes the union of the continuation of complexJoin() for both delta and old at
 a specific index for a given cluster;
 at least one of the tables must be new and of course not empty (as is the case for old
 information)</div>
</li>
</ul>
<a name="applyTests(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyTests</h4>
<pre>private&nbsp;void&nbsp;applyTests(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">in order to speed up rule execution, it is important to check whether the two
 variables in an in-eq constraint belong to a same rule cluster from the rule's
 cluster list;
 if so, the corresponding binding table can be "reduced" using the in-eq constraints;
 if not, the in-eq need to be considered later before/during RHS instantiation;
 examples
   + 1 LHS clause cluster:  ?x p ?y, ?y p ?z, ?x != ?y, ?y != ?z -> ?x p ?z
     do NOT iterate _twice_ over the binding table to check both in-eqs
   + 2 LHS clause clusters: ?u p ?v, ?x q ?y, ?u != ?y -> ?u r ?y
     in-eq applies to RHS, but RHS in principle requires Cartesian product of
     the two independent LHS clusters
   + 2 LHS clause clusters: ?u p ?v, ?x q ?y, ?u != ?x, ?v != ?y -> ?u r ?y
     both in-eqs can not be applied directly to LHS clusters, nor RHS, but
     in-eqs rule out certain combinations for (?u, ?y) that cooccur with
     (?u, ?x) and (?v, ?y)
   + in-eqs with URIs/XSD atoms: ?s ?p ?o, ?p != <rdf:type> -> .....</div>
</li>
</ul>
<a name="prepareInstantiation(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepareInstantiation</h4>
<pre>private&nbsp;void&nbsp;prepareInstantiation(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">computes delta, new, old, etc. for each independent LHS cluster (information
 stored in the cluster object);
 then (AT THE MOMENT) merges the LHS clusters using Cartesian Product, even if
 RHS pattern (or in-eqs/test) would _not_ enforce this;
 NOTE: standard OWL Horst rules come up with only one LHS cluster, so that
       Cartesian Product need not be carried out !!</div>
</li>
</ul>
<a name="complexProduct(de.dfki.lt.hfc.Cluster[], int, boolean, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>complexProduct</h4>
<pre>private&nbsp;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&nbsp;complexProduct(<a href="../../../../de/dfki/lt/hfc/Cluster.html" title="class in de.dfki.lt.hfc">Cluster</a>[]&nbsp;clusters,
                          int&nbsp;index,
                          boolean&nbsp;newInfo,
                          java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/BindingTable.html" title="class in de.dfki.lt.hfc">BindingTable</a>&gt;&nbsp;productit)</pre>
<div class="block">does the recursive job for prepareInstantiation();
 recursively takes the union of the continuation of complexProduct() for both delta and old
 of each cluster;
 at least one of the tables must be new and of course not empty (as is the case for old
 information) -- this is called "semi-naive evaluation" in logic programming</div>
</li>
</ul>
<a name="performInstantiation(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>performInstantiation</h4>
<pre>protected&nbsp;void&nbsp;performInstantiation(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">the input table for RHS instantiation has already been projected to the RHS variables</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/ForwardChainer.html#prepareInstantiation(de.dfki.lt.hfc.Rule)"><code>prepareInstantiation(de.dfki.lt.hfc.Rule)</code></a></dd></dl>
</li>
</ul>
<a name="execute(de.dfki.lt.hfc.Rule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>execute</h4>
<pre>protected&nbsp;void&nbsp;execute(<a href="../../../../de/dfki/lt/hfc/Rule.html" title="class in de.dfki.lt.hfc">Rule</a>&nbsp;rule)</pre>
<div class="block">performs the matching and instantiation for each rule;
 keeps track of local information in order to speed up rule execution;
 writes generated tuples to local output field of the rule</div>
</li>
</ul>
<a name="executeAllRules()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>executeAllRules</h4>
<pre>private&nbsp;void&nbsp;executeAllRules()</pre>
<div class="block">assigns each rule execution a single task which is added to the thread pool</div>
</li>
</ul>
<a name="computeClosure(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeClosure</h4>
<pre>public&nbsp;boolean&nbsp;computeClosure(int&nbsp;noOfIterations,
                     boolean&nbsp;cleanUpRepository)</pre>
<div class="block">computes the deductive closure given an initial set of tuples as
 specified by TupleStore.allTuples;
 iterates until a fixpoint is computed or a predefined iteration depth
 has been reached as given by the argument</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff new tuples have been generated</dd></dl>
</li>
</ul>
<a name="computeClosure()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeClosure</h4>
<pre>public&nbsp;boolean&nbsp;computeClosure()</pre>
<div class="block">the number of iterations is given by global this.noOfIterations;
 whether the repository is cleaned up is determined by ForwardChainer.cleanUpRepository
 and TupleStore.equivalenceClassReduction</div>
</li>
</ul>
<a name="computeClosure(java.util.Set, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeClosure</h4>
<pre>public&nbsp;boolean&nbsp;computeClosure(java.util.Set&lt;int[]&gt;&nbsp;newTuples,
                     int&nbsp;noOfIterations,
                     boolean&nbsp;cleanUpRepository)</pre>
<div class="block">calls computeClosure(int noOfIterations) again, assuming that a set of
 new tuples has been added to the tuple store;</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff new tuples have been generated</dd></dl>
</li>
</ul>
<a name="computeClosure(java.util.Set)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeClosure</h4>
<pre>public&nbsp;boolean&nbsp;computeClosure(java.util.Set&lt;int[]&gt;&nbsp;newTuples)</pre>
<div class="block">the number of iterations is given by field noOfIterations</div>
</li>
</ul>
<a name="uploadNamespaces(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uploadNamespaces</h4>
<pre>public&nbsp;void&nbsp;uploadNamespaces(java.lang.String&nbsp;filename)</pre>
<div class="block">uploads further namespaces stored in a file to an already established forward chainer;
 this method directly calls readNamespaces() from class Namespace</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>Namespace.readNamespaces()</code></dd></dl>
</li>
</ul>
<a name="uploadTuples(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uploadTuples</h4>
<pre>public&nbsp;void&nbsp;uploadTuples(java.lang.String&nbsp;filename)</pre>
<div class="block">uploads further tuples stored in a file to an already established forward chainer;
 this method directly calls readTuples() from class TupleStore;
 if tuple deletion is enabled in the forward chainer, the tuples from the file are
 assigned the actual generation TupleStore.generation</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.readTuples()</code></dd></dl>
</li>
</ul>
<a name="addTuples(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTuples</h4>
<pre>public&nbsp;void&nbsp;addTuples(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">add tuples, represented as int[], to the set of all tuples;
 if tuple deletion is enabled in the forward chainer, the tuples from the set are
 assigned the actual generation TupleStore.generation</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.addTuple()</code></dd></dl>
</li>
</ul>
<a name="removeTuples(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeTuples</h4>
<pre>public&nbsp;void&nbsp;removeTuples(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">remove tuples, represented as int[], from the set of all tuples;
 if tuple deletion is enabled in the forward chainer, the tuples from the set are
 removed from TupleStore.generation</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.addTuple()</code></dd></dl>
</li>
</ul>
<a name="uploadRules(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uploadRules</h4>
<pre>public&nbsp;void&nbsp;uploadRules(java.lang.String&nbsp;filename)</pre>
<div class="block">uploads further rules stored in a file to an already established forward chainer;
 the set of all rules is returned;
 NOTE: a similar method readRules() is defined in class RuleStore;
       however, uploadRules set the field noOfTasks in ForwardChainer to the proper value</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>RuleStore.readRules()</code></dd></dl>
</li>
</ul>
<a name="shutdown()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shutdown</h4>
<pre>public&nbsp;void&nbsp;shutdown()</pre>
<div class="block">shutdowns the thread pool and exits with value 0</div>
</li>
</ul>
<a name="shutdownNoExit()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shutdownNoExit</h4>
<pre>public&nbsp;void&nbsp;shutdownNoExit()</pre>
<div class="block">only shutdowns the thread pool, but no System.exit() is called;
 used by the XMLRPC server</div>
</li>
</ul>
<a name="compress(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compress</h4>
<pre>public&nbsp;void&nbsp;compress(int&nbsp;level)</pre>
<div class="block">if 0, auxiliary structures in forward chainer are not compressed/deleted;
 if 1, the old/new separation for clause proxies, clusters, and mega
       clusters is deleted;
 if 2, the index structure is deleted;
 if 3, old/new structures are deleted AND the index structure is deleted</div>
</li>
</ul>
<a name="deleteOldNew()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteOldNew</h4>
<pre>private&nbsp;void&nbsp;deleteOldNew()</pre>
</li>
</ul>
<a name="deleteIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteIndex</h4>
<pre>private&nbsp;void&nbsp;deleteIndex()</pre>
</li>
</ul>
<a name="uncompressIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uncompressIndex</h4>
<pre>public&nbsp;void&nbsp;uncompressIndex()</pre>
</li>
</ul>
<a name="copyForwardChainer(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyForwardChainer</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/ForwardChainer.html" title="class in de.dfki.lt.hfc">ForwardChainer</a>&nbsp;copyForwardChainer(int&nbsp;noOfCores,
                                boolean&nbsp;verbose)</pre>
<div class="block">returns a copy of the forward chainer that can be used to generate "choice points"
 during reasoning;
 tuples are taken over, but nearly everything else is copied</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>noOfCores</code> - an integer, specifying how many parallel threads are used during
        the computation of the deductive closure for the copy of this forward chainer</dd><dt><span class="strong">See Also:</span></dt><dd><code>de.dfki.lt.hfc.TupleStore.copyTupleStore()</code>, 
<code>de.dfki.lt.hfc.TupleStore.copyRuleStore()</code></dd></dl>
</li>
</ul>
<a name="tupleDeletionEnabled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tupleDeletionEnabled</h4>
<pre>public&nbsp;boolean&nbsp;tupleDeletionEnabled()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff tuple deletion has been enabled by method enableTupleDeletion()</dd><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.tupleDeletionEnabled()</code></dd></dl>
</li>
</ul>
<a name="enableTupleDeletion()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enableTupleDeletion</h4>
<pre>public&nbsp;boolean&nbsp;enableTupleDeletion()</pre>
<div class="block">enableTupleDeletion() makes use of a special field that is initialized by an empty map
 from tuples (int[]) to generations (Integer);
 this field is localized in class TupleStore, since it interacts with the equivalence
 class reduction mechanism that is also located in TupleStore;</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff tuple deletion has been successfully started</dd><dt><span class="strong">See Also:</span></dt><dd><code>this special case of tuple deletion differs from the functionality in class TupleStore
 which only deletes tuples given to method removeTuple(), in that _entailed_ tuples t'
 which potentially depend on the deleted tuple t (gen(t') > gen(t)) must also be deleted
 AND closure computation needs to be called again

 IMPORTANT:
   use this and only this method to enable tuple deletion in the forward chainer;

 it is IMPORTANT that this method is DIRECTLY called AFTER an instance of ForwardChainer
 has been created and before the first closure computation is called;
 if it would be called some time later AFTER at least one closure computation has been
 called, i.e., if (TupleStore.generation > 0), the method will do NOTHING (and returns
 false);
 when this method returns true, it is guaranteed that all tuples from the tuple store
 are assigned generation 0</code></dd></dl>
</li>
</ul>
<a name="deleteTuple(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteTuple</h4>
<pre>public final&nbsp;boolean&nbsp;deleteTuple(int[]&nbsp;tuple)</pre>
<div class="block">deletes a tuple and _potentially_ dependent entailed tuples of specific generations from the
 tuples store, followed by a new closure computation;
 note that we need to check whether equivalence class reduction has been turned on; if so, the
 tuple needs to be replaced by its proxy!

 this strategy implements a compromise between deleting everything and setting up a full
 TMS-like structure (that would furthermore make speed-up techniques in HFC obsolete);

 use deleteTuples() below if you want to delete more than one tuple, since deleteTuples()
 calls closure computation only once at the very end of the deletion process, whereas this method
 calls it for the tuple bound to parameter tuple

 note: this method obtains a lock of this.tupleStore</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff tuple was successfully deleted, i.e., was an element of the set of all tuples</dd></dl>
</li>
</ul>
<a name="deleteTuples(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteTuples</h4>
<pre>public final&nbsp;boolean&nbsp;deleteTuples(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">use this method if you want to delete SEVERAL tuples at once, since both this and the above method
 always call computeClosure() at the very end (expensive!), independent of the number of tuples deleted

 note: this method obtains a lock of this.tupleStore</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff each tuple from tuples was successfully deleted (OR tuples is the empty collection)</dd></dl>
</li>
</ul>
<a name="addTuplesToRepository(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTuplesToRepository</h4>
<pre>public final&nbsp;boolean&nbsp;addTuplesToRepository(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">transaction 1: addTuplesToRepository()
 adds a collection of tuples to the repository;
 this quasi-synchronized method obtains a lock on this.tupleStore;
 note that the generation counter from TupleStore is incremented by 2 _before_
 the tuples are added in order to distinguish the tuples envolved in this transactions
 from `ordinary' tuples that are `only' uploaded;
 note further that this transaction does NOT compute the deductive closure of the repository</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff the transaction was successful</dd></dl>
</li>
</ul>
<a name="removeTuplesFromRepository(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeTuplesFromRepository</h4>
<pre>public final&nbsp;boolean&nbsp;removeTuplesFromRepository(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">transaction 2: removeTuplesFromRepository()
 removes a collection of tuples from the repository;
 note that the entailed tuples are NOT deleted, only the specified tuples;
 in case closure computation is never called, i.e., the repository is only used for
 querying the explicit uploaded information, use this method instead of nethod below;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff the transaction was successful</dd><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.deleteTuplesFromRepository()</code></dd></dl>
</li>
</ul>
<a name="deleteTuplesRecordGenerations(java.util.Collection, java.util.Hashtable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteTuplesRecordGenerations</h4>
<pre>private final&nbsp;boolean&nbsp;deleteTuplesRecordGenerations(java.util.Collection&lt;int[]&gt;&nbsp;tuples,
                                    java.util.Hashtable&lt;int[],java.lang.Integer&gt;&nbsp;mapping)</pre>
<div class="block">this private method differs from deleteTuples() above in that it destructively modifies
 the tuple-to-be-deleted-TO-generation mapping as given by parameter mapping and is
 exclusively used by deleteFromRepository()</div>
</li>
</ul>
<a name="deleteTuplesFromRepository(java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteTuplesFromRepository</h4>
<pre>public final&nbsp;boolean&nbsp;deleteTuplesFromRepository(java.util.Collection&lt;int[]&gt;&nbsp;tuples)</pre>
<div class="block">transaction 3: deleteTuplesFromRepository()
 deletes a collection of tuples from the repository; not only the direct tuples
 are deleted, but also the entailed tuples which solely depend on the deleted
 tuples;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff the transaction was successful</dd><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.removeTuplesFromRepository()</code></dd></dl>
</li>
</ul>
<a name="computeClosureFromRepository()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeClosureFromRepository</h4>
<pre>public final&nbsp;boolean&nbsp;computeClosureFromRepository()</pre>
<div class="block">transaction 4: computeClosureFromRepository()
 a `nullary' transaction that computes the deductive closure for the repository;
 this quasi-synchronized method obtains a lock on this.tupleStore</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff the transaction was successful</dd><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.removeFromRepository()</code></dd></dl>
</li>
</ul>
<a name="main(java.lang.String[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(java.lang.String[]&nbsp;args)
                 throws java.lang.Exception</pre>
<div class="block">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! FOR TEST PURPOSES ONLY !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../de/dfki/lt/hfc/Configuration.html" title="class in de.dfki.lt.hfc"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../de/dfki/lt/hfc/Function.html" title="class in de.dfki.lt.hfc"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?de/dfki/lt/hfc/ForwardChainer.html" target="_top">Frames</a></li>
<li><a href="ForwardChainer.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
