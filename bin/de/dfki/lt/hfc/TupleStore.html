<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_60) on Fri Aug 29 12:01:29 CEST 2014 -->
<title>TupleStore</title>
<meta name="date" content="2014-08-29">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="TupleStore";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../de/dfki/lt/hfc/TupleComparator.html" title="class in de.dfki.lt.hfc"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?de/dfki/lt/hfc/TupleStore.html" target="_top">Frames</a></li>
<li><a href="TupleStore.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">de.dfki.lt.hfc</div>
<h2 title="Class TupleStore" class="title">Class TupleStore</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>de.dfki.lt.hfc.TupleStore</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public final class <span class="strong">TupleStore</span>
extends java.lang.Object</pre>
<div class="block">tuples are represented as int[] in order to save space;
 although container objects (embodying the int[]) are easier to
 handle -- we can define proper equals() and hashCode() methods for
 them -- I have opted for simple plain int[];
 this, however, requires that we need our own tuple set class, originally
 called IntArrayHashSet (plus IntArrayHashMap), since the standard equals()
 and hashCode() for int[] yield wrong results;
 later, I switched to Trove's THashSet and THashMap classes which further
 speed up runtime performance

 since we allow for tuples of arbitrary length, we have decided
 against reification, i.e., against tuples containing (sub-)tuples;
 reification furthermore makes the matching phase of a forward chainer
 (destructuring!) more complex, sinces simple and effective matching
 techniques are no longer applicable

 the index data structure is used to find all those tuples which
 contain an object represented as an int at a specific position int
 the tuple -- use getTuples(int pos, int obj) to obtain a Set<Tuple>;
 in order to perform more complex queries we can either use set operations
 on the returned Set<Tuple> or by creating more complex index keys,
 e.g., in case of a triple to have keys that look at the 1st+2nd, 1st+3rd,
 2nd+3rd, and 1st+2nd+3rd position, resp.
 it is very likely that complex indexes are too expensive in terms of memory,
 since the corresponding sets are only sparsely populated;
 note that value identity between tuple positions is NOT encoded in the index;
 furthermore, a restriction on the length of a tuple is also NOT built into
 the index</div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>JDK 1.5</dd>
<dt><span class="strong">See Also:</span></dt><dd><code>gnu.trove.THashSet</code>, 
<a href="../../../../de/dfki/lt/hfc/TIntArrayHashingStrategy.html" title="class in de.dfki.lt.hfc"><code>TIntArrayHashingStrategy</code></a>, 
<a href="../../../../de/dfki/lt/hfc/RuleStore.html" title="class in de.dfki.lt.hfc"><code>RuleStore</code></a>, 
<a href="../../../../de/dfki/lt/hfc/ForwardChainer.html" title="class in de.dfki.lt.hfc"><code>ForwardChainer</code></a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../../de/dfki/lt/hfc/AggregateRegistry.html" title="class in de.dfki.lt.hfc">AggregateRegistry</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#aggregateRegistry">aggregateRegistry</a></strong></code>
<div class="block">this registry object gathers the aggregational operators potentially used
 during querying (AGGREGATE) and forward chaining (all-rules), and so during
 the interactive mode;
 since all these modes need a tuple store and since the registry requires
 the tuple store as an internal state, we automatically constructs a new
 registry every time a new tuple store is build</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#allTuples">allTuples</a></strong></code>
<div class="block">a set of all tuples known to TupleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#currentId">currentId</a></strong></code>
<div class="block">URIs and XSD literals are replaced when they are read in by their IDs,
 usually ints (perhaps use longs if there are too many atoms), starting
 with 0
 the value 0 is used during rule application to indicate that a variable
 is unbound or its value is not of interest;
 negative integers represent (local) variable names</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static <a href="../../../../de/dfki/lt/hfc/TIntArrayHashingStrategy.html" title="class in de.dfki.lt.hfc">TIntArrayHashingStrategy</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#DEFAULT_HASHING_STRATEGY">DEFAULT_HASHING_STRATEGY</a></strong></code>
<div class="block">the default hashing (and equals) strategy for tuples from the tuple store
 (all positions of a tuple are taken into account);
 make it static, so that it can be reused for the sets at the leaves of the
 index!</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#equivalenceClassReduction">equivalenceClassReduction</a></strong></code>
<div class="block">an optimization, currently applicable only to
   + owl:sameAs
   + owl:equivalentClass
   + owl:equivalentProperty
 but not to general equivalence relations, i.e., relations which are
 reflexive, symmetric, and transitive;
 this optimization influences input/output of methods from the following
 Java classes:
   + TupleStore
   + RuleStore
   + Query
 NOTE: once tuples have been read into the tuple store, do NOT change the
       value of _this_ field !!
 NOTE: assigning a URI (in subject or object position) to different equivalence
       relations, e.g.,
         <a> <owl:sameAs> <b>
         <a> <owl:equivalentProperty> <c>
       might lead to wrong results when querying a repository (at the same time,
       this is only allowed in OWL Full);
 NOTE: make sure to load the right rule file, depending on the value of this
       field!!</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#exitOnError">exitOnError</a></strong></code>
<div class="block">a constant that controls whether the system is terminated in case an invalid
 tuple is read in (exit code = 1);
 a similar variable exists in class RuleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#generation">generation</a></strong></code>
<div class="block">this field serves a different purpose compared to field ForwardChainer.generationCounter
 and is solely used when tuple deletion is enabled in the forward chainer;
 this field is incremented by 1 before closure computation is called and is incremented
 again after closure computation;
 this strategy makes sure that the entailed tuples are assigned an ODD generation number,
 whereas uploaded tuples are automatically assigned an EVEN number</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#idToJavaObject">idToJavaObject</a></strong></code>
<div class="block">a mapping used by functional constraints to speed up processing</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.util.ArrayList&lt;java.lang.String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#idToObject">idToObject</a></strong></code>
<div class="block">used during output, when IDs (ints) are replaced by URI or XSD names</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Map&lt;java.lang.Integer,java.util.Set&lt;int[]&gt;&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#index">index</a></strong></code>
<div class="block">the index data structure is used to find all those tuples which contain an
 object represented as an int at a specific position;

 NOTE: it _might_ be better to use Trove's TIntObjectHashMap class here
       checked it, even slightly _worse_ (HUK)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#INPUT_CHARACTER_ENCODING">INPUT_CHARACTER_ENCODING</a></strong></code>
<div class="block">this setting is used for input encoding in TupleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#maxNoOfArgs">maxNoOfArgs</a></strong></code>
<div class="block">this constant is used to create the right number of index tables;
 note that the value of this constant has an effect on the index data
 structure; the larger the number, the more tables are created;
 reasonable values seem to be 3 (RDF triple), 4 (time or negation, 5 (time),
 or 6 (time and negation);
 a similar variable exists in class RuleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#minNoOfArgs">minNoOfArgs</a></strong></code>
<div class="block">it seems reasonable to have tuples of at least length 1;
 use value 3 to be compliant with RDF;
 a similar variable exists in class RuleStore</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#namespace">namespace</a></strong></code>
<div class="block">a namespace object used to expand short form namespaces into full forms</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#OBJECT_POSITION">OBJECT_POSITION</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.HashMap&lt;java.lang.String,java.lang.Integer&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#objectToId">objectToId</a></strong></code>
<div class="block">used during input, when URIs, blank nodes, or XSD atoms are replaced by their IDs (ints)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../../../de/dfki/lt/hfc/OperatorRegistry.html" title="class in de.dfki.lt.hfc">OperatorRegistry</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#operatorRegistry">operatorRegistry</a></strong></code>
<div class="block">this registry object gathers the functional operators potentially used
 during querying (FILTER) and forward chaining (LHS matching via predicates
 and RHS generation of new individuals via functions), and so during the
 interactive mode;
 since all these modes need a tuple store and since the registry requires
 the tuple store as an internal state, we automatically constructs a new
 registry every time a new tuple store is build</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#OUTPUT_CHARACTER_ENCODING">OUTPUT_CHARACTER_ENCODING</a></strong></code>
<div class="block">this setting is used for output encoding in TupleStore</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#PREDICATE_POSITION">PREDICATE_POSITION</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <any></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#proxyToUris">proxyToUris</a></strong></code>
<div class="block">a mapping from a proxy to its equivalence class, represented as an
 array list of ints</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#rdfCheck">rdfCheck</a></strong></code>
<div class="block">when tuples are read in, this variable decides whether tuples are compliant with
 what RDF requests, viz., that the first argument is either an URI or a blank node,
 and that the second arg is a URI</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#SUBJECT_POSITION">SUBJECT_POSITION</a></strong></code>
<div class="block">specifies the position of the subject, predicate, and object in an RDF triple
   0 : subject
   1 : predicate
   2 : object
 in case we would move the predicate to the front, predicatePosition must be
 set to 0, subject to 1, and object to 2, even if we would allow for tuples
 of length > 3 (interpret this as "the object, given as a Cartesian product,
 starts at position 2)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <any></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#tupleToGeneration">tupleToGeneration</a></strong></code>
<div class="block">a special field that is initialized by an empty map from tuples (int[]) to generations
 (Integer) in case tuple deletion is switched on through method enableTupleDeletion() in
 the forward chainer</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected TIntIntHashMap</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#uriToEquivalenceRelation">uriToEquivalenceRelation</a></strong></code>
<div class="block">a mapping from URI in subject/object position to the equivalence
 relation name (internal ID) in predicate position</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected TIntIntHashMap</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#uriToProxy">uriToProxy</a></strong></code>
<div class="block">a mapping from the internal representation of URIs (ints) to their
 representatives/proxies, again internal representation of URIs;
 only URIs mentioned in sameAs, equivalentClass, and equivalentProperty
 statements are entered here (at the moment)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#verbose">verbose</a></strong></code>
<div class="block">a constant that controls whether a warning is printed in case an invalid
 tuple is read in;
 a similar variable exists in class RuleStore</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier</th>
<th class="colLast" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private </code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore()">TupleStore</a></strong>()</code>
<div class="block">(should) only (be) used by copyTupleStore()</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(boolean,%20boolean,%20boolean,%20int,%20int,%20int,%20int,%20de.dfki.lt.hfc.Namespace,%20java.lang.String)">TupleStore</a></strong>(boolean&nbsp;verbose,
          boolean&nbsp;rdfCheck,
          boolean&nbsp;eqReduction,
          int&nbsp;minNoOfArgs,
          int&nbsp;maxNoOfArgs,
          int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</code>
<div class="block">more options to fully parameterize the tuple store</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(int,%20int)">TupleStore</a></strong>(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples)</code>
<div class="block">choose a proper noOfAtoms/noOfTuples in order not to arrive at copying the
 elements into a larger structure; keep in mind that other services (e.g.,
 rule application) can drastically increase the number of tuples</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(int,%20int,%20de.dfki.lt.hfc.Namespace)">TupleStore</a></strong>(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</code>
<div class="block">extends the binary constructor with the ability to read in a namespace</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(int,%20int,%20de.dfki.lt.hfc.Namespace,%20java.lang.String)">TupleStore</a></strong>(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</code>
<div class="block">extends the binary constructor with the ability to read in a namespace and a
 textual representation of facts (basically N-Triples syntax), stored in a file</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(de.dfki.lt.hfc.Namespace)">TupleStore</a></strong>(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</code>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#TupleStore(de.dfki.lt.hfc.Namespace,%20java.lang.String)">TupleStore</a></strong>(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</code>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addEquivalentElements(int,%20int)">addEquivalentElements</a></strong>(int&nbsp;left,
                     int&nbsp;right)</code>
<div class="block">three cases to distinguish here:
 (1) left and right are _not_ keys in uriToProxy
 (2) left xor right is a key in uriToProxy
 (3) left and right are keys in uriToProxy

 NOTE: we do make this method synchronized, since certain rule operators
       use this method</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addToIndex(int[])">addToIndex</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">I separated this code from the addTuple method above to make it
 accessible from other classes</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[]</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addTuple(java.util.ArrayList,%20int)">addTuple</a></strong>(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple,
        int&nbsp;lineNo)</code>
<div class="block">addTuple() assumes a textual tuple representation after tokenization
 (an array list of strings);
 the bidirectional mapping is established and the index is updated;
 this method is used when an external tuple file is read in;
 lineNo refers to the line number in the file that is read in</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addTuple(int[])">addTuple</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">addTuple() assumes an int[] as input (the tuple);
 the mappings are established and the index is updated;
 this method does not check whether the representation is valid;
 addTuple() also adds the tuple to the set of all tuples;
 if tuple deletion is enabled, addTuple() also updates the tuple-
 to-generation mapping;
 returns true iff the set of all tuple did not already contain the
 argument tuple</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addTuple(java.lang.String[])">addTuple</a></strong>(java.lang.String[]&nbsp;stringTuple)</code>
<div class="block">addTuple(String[]) performs the internalization and then calls addTuple(int[])</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#addTupleWithGeneration(int[],%20int)">addTupleWithGeneration</a></strong>(int[]&nbsp;tuple,
                      int&nbsp;gennum)</code>
<div class="block">helper for cleanUpTupleStore;
 differs from addTuple(int[]) in that it carries a second argument, the
 generation (an int) that is used as the generation for the tuple argument
 in case tuple deletion is enabled</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#ask(java.util.ArrayList)">ask</a></strong>(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;externalTuple)</code>
<div class="block">checks whether a tuple (represented as an array list of strings) is contained
 in the tuple store</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#ask(int[])">ask</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">use this method for containment test in order not to make this.allTuples public</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#ask(java.lang.String[])">ask</a></strong>(java.lang.String[]&nbsp;externalTuple)</code>
<div class="block">checks whether a tuple (represented as a string array) is contained in the
 tuple store</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#cleanUpTupleStore()">cleanUpTupleStore</a></strong>()</code>
<div class="block">remove those tuples from the set of all tuples and from the index which have
 an equivalence relation in predicate position;
 only keep exactly one triple for each proxy p with its corresponding equivalence relation r:
   p r p</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#containsPrefixPattern(java.lang.String[])">containsPrefixPattern</a></strong>(java.lang.String[]&nbsp;prefixPattern)</code>
<div class="block">checks whether matchPrefixPattern() returns a NON-empty set
 NOTE: this method will only work for patterns not longer than the size of the index
       and for non-empty patterns and patterns not consisting of variables only</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private java.util.Map&lt;java.lang.Integer,java.util.Set&lt;int[]&gt;&gt;[]</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#copyIndex()">copyIndex</a></strong>()</code>
<div class="block">returns a nearly-deep copy of the index: everything is copied with the notable
 exception of the tuples (the int arrays) at the leaves of the index</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#copyTupleStore(de.dfki.lt.hfc.Namespace)">copyTupleStore</a></strong>(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</code>
<div class="block">returns a copy of the tuple store that can be used to generate "choice points",
 e.g., during reasoning, as is done by the forward chainer</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#ensureEqualVariables(java.util.Set,%20int[][])">ensureEqualVariables</a></strong>(java.util.Set&lt;int[]&gt;&nbsp;input,
                    int[][]&nbsp;duplPos)</code>
<div class="block">destructively reduces the input set by making sure that columns headed
 by the same variable hold the same value;
 example (duplPos vectors are _sorted_):
   rule pattern: <?x, ?y, ?x, ?y, ?x>
   duplPos: [[0, 2, 4], [1, 3]]
   input: <a, b, a, b, a>  OK!</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getAllTuples()">getAllTuples</a></strong>()</code>
<div class="block">returns the set of all tuples</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getJavaObject(int)">getJavaObject</a></strong>(int&nbsp;id)</code>
<div class="block">returns a Java object for a given literal, internally represented by parameter id;
 Java classes have been defined for the following types of literals:
   URI            -> de.dfki.lt.hfc.types.Uri
   blank node     -> de.dfki.lt.hfc.types.BlankNode
   xsd:int        -> de.dfki.lt.hfc.types.XsdInt
   xsd:long       -> de.dfki.lt.hfc.types.XsdLong
   xsd:float      -> de.dfki.lt.hfc.types.XsdFloat
   xsd:double     -> de.dfki.lt.hfc.types.XsdDouble
   xsd:string     -> de.dfki.lt.hfc.types.XsdString
   xsd:boolean    -> de.dfki.lt.hfc.types.XsdBoolean
   xsd:dateTime   -> de.dfki.lt.hfc.types.XsdDateTime
   xsd:date       -> de.dfki.lt.hfc.types.XsdDate
   xsd:gYear      -> de.dfki.lt.hfc.types.XsdGYear
   xsd:gYearMonth -> de.dfki.lt.hfc.types.XsdGYearMonth
   xsd:gMonth     -> de.dfki.lt.hfc.types.XsdGMonth
   xsd:gMonthDay  -> de.dfki.lt.hfc.types.XsdGMonthDay
   xsd:gDay       -> de.dfki.lt.hfc.types.XsdGDay
   xsd:duration   -> de.dfki.lt.hfc.types.XsdDuration
   xsd:uDateTime  -> de.dfki.lt.hfc.types.XsdUDateTime
   xsd:monetary   -> de.dfki.lt.hfc.types.XsdMonetary
   xsd:anyURI     -> de.dfki.lt.hfc.types.XsdAnyURI

 this is a lazy method, calling makeJavaObject() in case no Java object has been
 created so far for id</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getNextId()">getNextId</a></strong>()</code>
<div class="block">return a brand new id, resulting from the very last id, incremeted by 1 (values 0--5
 are reserved)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getObject(int)">getObject</a></strong>(int&nbsp;id)</code>
<div class="block">returns the the textual representation for id (an int);
 notice that since tuples are not always grounded (since they are
 used in the antecedent and consequent of a rule, where variables occur),
 we return the id prefixed by '?' in case id encodes a variable</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getProxy(int)">getProxy</a></strong>(int&nbsp;uri)</code>
<div class="block">returns the proxy for URI uri iff uri is a key in uriToProxy;
 otherwise, uri is returned</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getTuples(int,%20int)">getTuples</a></strong>(int&nbsp;pos,
         int&nbsp;obj)</code>
<div class="block">obtains all those tuples which contain an object obj (represented as an int)
 at a specific position pos in a tuple (an int);
 NOTE: the set which is returned is part of the index and thus should NOT be
       modified!!!</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#getTuples(int,%20java.lang.String)">getTuples</a></strong>(int&nbsp;pos,
         java.lang.String&nbsp;obj)</code>
<div class="block">instead of using the obj id (an int), one can alternatively specify the object
 directly;
 NOTE: check whether you must use the short or long namespace prefix depending on
       Namespace.shortIsDefault</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#init(boolean,%20boolean,%20boolean,%20int,%20int,%20int,%20int)">init</a></strong>(boolean&nbsp;verbose,
    boolean&nbsp;rdfCheck,
    boolean&nbsp;eqReduction,
    int&nbsp;minNoOfArgs,
    int&nbsp;maxNoOfArgs,
    int&nbsp;noOfAtoms,
    int&nbsp;noOfTuples)</code>
<div class="block">init form that "outsources" initialization code that needs to be duplicated by the
 binary (that is used be several other constructors) and 8-ary constructor</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#initializeUriMappings()">initializeUriMappings</a></strong>()</code>
<div class="block">specify mappings here that stay constant for efficiency reasons, independent of
 whether these URIs are seen first at different places in a file that is read in;
 currently, the following mappings are predefined for the following URIs (URI : id):
   NULL : 0, commented out at the moment, since it might interfere with Calc.restrict()
   rdfs:subClassOf : 1
   owl:sameAs : 2
   owl:equivalentClass : 3
   owl:equivalentProperty : 4
   owl:disjointWith : 5</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#internalizeTuple(java.util.ArrayList)">internalizeTuple</a></strong>(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple)</code>
<div class="block">internalizeTuple() maps array lists of strings to int arrays of unique
 ints;
 uses putObject() to generate new ints in case the string argument is
 brand new, or retrieves the already generated int in case the string
 argument has already been seen</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#internalizeTuple(java.lang.String[])">internalizeTuple</a></strong>(java.lang.String[]&nbsp;stringTuple)</code>
<div class="block">internalizeTuple() maps string arrays to int arrays of unique ints;
 uses putObject() to generate new ints in case the string argument is
 brand new, or retrieves the already generated int in case the string
 argument has already been seen</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isAtom(int)">isAtom</a></strong>(int&nbsp;id)</code>
<div class="block">given an id (an int), returns true iff id represents a XSD atom;
 false, otherwise</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isAtom(java.lang.String)">isAtom</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isAtom() returns true iff literal is an XSD atom; false, otherwise</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isBlankNode(int)">isBlankNode</a></strong>(int&nbsp;id)</code>
<div class="block">given an id (an int), returns true iff id represents a blank node;
 false, otherwise</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isBlankNode(java.lang.String)">isBlankNode</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isBlankNode() returns true iff literal is a blank node; false, otherwise</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isConstant(int)">isConstant</a></strong>(int&nbsp;id)</code>
<div class="block">internal representation: constants are positive numbers</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isConstant(java.lang.String)">isConstant</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">tests whether literal is a constant (i.e., URI, blank node, or XSD atom) as known
 by the tuple store; i.e., literal must be part of a tuple that has been added to
 the tuple store;
 NOTE: false does NOT indicate that literal is a variable!</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isEquivalenceRelation(int[])">isEquivalenceRelation</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">given a tuple, isEquivalenceRelation() determines whether the predicate
 in position this.predicatePosition is an equivalence relation;
 currently, owl:sameAs, owl:equivalentClass, and owl:equivalentProperty
 are recognized here as given by the integers
   Namespace.OWL_SAMEAS_ID
   Namespace.OWL_EQUIVALENTCLASS_ID
   Namespace.OWL_EQUIVALENTPROPERTY_ID</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isUri(int)">isUri</a></strong>(int&nbsp;id)</code>
<div class="block">given an id (an int), returns true iff id represents a URI;
 false, otherwise</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isUri(java.lang.String)">isUri</a></strong>(java.lang.String&nbsp;literal)</code>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isUri() returns true iff literal is a URI; false, otherwise</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#isValidTuple(java.util.ArrayList,%20int)">isValidTuple</a></strong>(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple,
            int&nbsp;lineNo)</code>
<div class="block">checks whether a tuple of proper length as specified by this.minNoOfArgs
 and this.maxNoOfArgs;

 also checks whether the arguments of a tuple are of the right "kind":
   arg 1: URI or blank node
   arg 2: URI
   arg 3, 4, ...</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#main(java.lang.String[])">main</a></strong>(java.lang.String[]&nbsp;args)</code>
<div class="block">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! FOR TEST PURPOSES ONLY !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private <a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a></code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#makeJavaObject(int)">makeJavaObject</a></strong>(int&nbsp;id)</code>
<div class="block">for each new URI, blank node, or XSD atom, we construct a new Java
 object on _demand_ when calling makeJavaObject();
 the idea is that external functional operators will proceed faster
 when directly working on the Java objects instead on working on the
 external string representation which needs to be manipulated;
 Java classes have been defined for the following kinds of literals:
   URI            -> de.dfki.lt.hfc.types.Uri
   blank node     -> de.dfki.lt.hfc.types.BlankNode
   xsd:int        -> de.dfki.lt.hfc.types.XsdInt
   xsd:long       -> de.dfki.lt.hfc.types.XsdLong
   xsd:float      -> de.dfki.lt.hfc.types.XsdFloat
   xsd:double     -> de.dfki.lt.hfc.types.XsdDouble
   xsd:string     -> de.dfki.lt.hfc.types.XsdString
   xsd:boolean    -> de.dfki.lt.hfc.types.XsdBoolean
   xsd:dateTime   -> de.dfki.lt.hfc.types.XsdDateTime
   xsd:date       -> de.dfki.lt.hfc.types.XsdDate
   xsd:gYear      -> de.dfki.lt.hfc.types.XsdGYear
   xsd:gYearMonth -> de.dfki.lt.hfc.types.XsdGYearMonth
   xsd:gMonth     -> de.dfki.lt.hfc.types.XsdGMonth
   xsd:gMonthDay  -> de.dfki.lt.hfc.types.XsdGMonthDay
   xsd:gDay       -> de.dfki.lt.hfc.types.XsdGDay
   xsd:duration   -> de.dfki.lt.hfc.types.XsdDuration
   xsd:uDateTime  -> de.dfki.lt.hfc.types.XsdUDateTime
   xsd:monetary   -> de.dfki.lt.hfc.types.XsdMonetary
   xsd:anyURI     -> de.dfki.lt.hfc.types.XsdAnyURI

 NOTE: if further (XSD) types are added, this method needs to be adjusted
       as well as the Namespace class
 NOTE: in case we we have found an unknown literal type, null is returned
       and a message is printed out to the console</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#matchPrefixPattern(java.lang.String[])">matchPrefixPattern</a></strong>(java.lang.String[]&nbsp;prefixPattern)</code>
<div class="block">returns those ground tuples g = p+s, such that p matches the prefix pattern parameter;
 a pattern is composed of variables, URIs, and XSD atoms;
 note that the name of a variable does NOT matter, and thus a pattern such as
   ?s <foo> ?s <bar>
 does NOT enforce that the matching tuples must have identical values in first and third
 position;
 note that tuples must be at least as long as the pattern to be successfully matching
 candidates; so, for instance, w.r.t.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#parseAtom(java.util.StringTokenizer,%20java.util.ArrayList)">parseAtom</a></strong>(java.util.StringTokenizer&nbsp;st,
         java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</code>
<div class="block">XSD atoms are strings optionally followed by either a type identifier (^^type)
 or a language tag (@lang);
 within the preceding string, further strings are allowed, surrounded by "\"",
 as well as spaces, "\\", etc.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#parseBlankNode(java.util.StringTokenizer,%20java.util.ArrayList)">parseBlankNode</a></strong>(java.util.StringTokenizer&nbsp;st,
              java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</code>
<div class="block">a blank node starts with a "_:" and ends before the next whitespace character,
 i.e., no whitespaces are allowed inside the name of the blank node;
 since, blank nodes make no reference to a namespace, we make this a static method</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#parseURI(java.util.StringTokenizer,%20java.util.ArrayList)">parseURI</a></strong>(java.util.StringTokenizer&nbsp;st,
        java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</code>
<div class="block">a URI starts with a '<' and ends with a '>';</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#parseVariable(java.util.StringTokenizer,%20java.util.ArrayList)">parseVariable</a></strong>(java.util.StringTokenizer&nbsp;st,
             java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</code>
<div class="block">variables in a rule or query tuple start with a '?' char and are followed by a string,
 containing no whitespace chars;
 since variables make no reference to a namespace, we make this a static method</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#printTuple(int[],%20java.util.ArrayList)">printTuple</a></strong>(int[]&nbsp;tuple,
          java.util.ArrayList&lt;java.lang.String&gt;&nbsp;mapping)</code>
<div class="block">a simple STATIC method, translating an int array into something readable (N-tuple syntax)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#putObject(java.lang.String)">putObject</a></strong>(java.lang.String&nbsp;obj)</code>
<div class="block">obj is either a URI or an XSD literal, encoded as a string;
 in case obj has not been seen before, the method assigns a new id (an int) to
 obj, establishes a bidirectional mapping between obj and id, and returns the
 new id;  otherwise, the already existing id for obj is returned</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#queryIndex(int[],%20de.dfki.lt.hfc.Table)">queryIndex</a></strong>(int[]&nbsp;pattern,
          <a href="../../../../de/dfki/lt/hfc/Table.html" title="class in de.dfki.lt.hfc">Table</a>&nbsp;table)</code>
<div class="block">queries the index, given a rule pattern, consisting of constants and variables;
 potentially performs several calls to the index using getTuples(), followed by
 non-destructive set intersection operations that take into account the "relevant
 positions" of the input pattern which influences the hashing strategy;
 NOTE: the result set is NOT shared by the index, thus can be destructively
       modified without having any effect on the index !!</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readAllTuples(java.io.BufferedReader,%20int)">readAllTuples</a></strong>(java.io.BufferedReader&nbsp;br,
             int&nbsp;noOfLines)</code>
<div class="block">helper for readTupleStore()</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readIdToObject(java.io.BufferedReader,%20int)">readIdToObject</a></strong>(java.io.BufferedReader&nbsp;br,
              int&nbsp;noOfLines)</code>
<div class="block">helper for readTupleStore()</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readObjectToId(java.io.BufferedReader,%20int)">readObjectToId</a></strong>(java.io.BufferedReader&nbsp;br,
              int&nbsp;noOfLines)</code>
<div class="block">helper for readTupleStore()</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readTuples(java.lang.String)">readTuples</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">readTuples() reads in a sequence of tuples from a text file;
 tuples must be finished in a _single_ line, constrained by the following
 side conditions:
   + a tuple starts with an URI or a blank node
   + tuples must have at least one argument
   + elements of a tuple (URIs, blank nodes, XSD atoms) must be separated
     by the space character ' '
   + URIs start with "<" and end with ">" (both for short and long prefixes)
   + blank nodes start with "_:"
   + XSD atoms start with '"' and ends with '"', potentially followed by type
     or language information; inside the leading string value, strings must
     be enclosed by "\""
   + comments only start with the '#' character at the very first position of
     a line
   + tuples need not end with the '.' character

 this is essentially N-Triples syntax, see
   Jan Grant & Dave Beckett: RDF Test Cases, 10 Feb 2004.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Set&lt;int[]&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readTupleStore(java.lang.String)">readTupleStore</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">reads in a 'compressed' tuple store (extension usually "ts") generated by
 writeTupleStore(); usage:
   Namespace ns = new Namespace("...");
   TupleStore ts = new TupleStore(ns);
   ts.readTupleStore("...");</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#registerJavaObject(java.lang.String,%20de.dfki.lt.hfc.types.AnyType)">registerJavaObject</a></strong>(java.lang.String&nbsp;literal,
                  <a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&nbsp;javaObject)</code>
<div class="block">this synchronized method can be called by functional operators in order
 to establish an association between a literal (e.g., URI, XSD string, XSD
 int, etc.) and a Java object (subtypes of AnyType);
 furthermore, a new int (an ID) is returned that is internally used in the
 tuple store</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#removeTuple(int[])">removeTuple</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">removes the tuple from the set of all tuples and cleans up the index structure;
 if tuple deletion is enabled, the tuple-generation pair is also removed from the
 tuple-to-generation mapping;
 returns true iff the set of all tuples contained the specified tuple;
 false otherwise (= nothing is removed)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#removeTupleReturnGeneration(int[])">removeTupleReturnGeneration</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">differs from removeTuple() in that it returns the generation of the tuple
 that is going to be deleted;
 returns -1 in case the tuple is not part of the repository</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#sayItLoud(int,%20java.lang.String)">sayItLoud</a></strong>(int&nbsp;lineNo,
         java.lang.String&nbsp;message)</code>
<div class="block">at several places, messages were output depending on this.exitOnError
 and this.verbose -- unify this in this special private method;
 perhaps will be replaced by Apache's log4j</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#sayItLoud(java.lang.String)">sayItLoud</a></strong>(java.lang.String&nbsp;message)</code>
<div class="block">same method without the line numbering</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#toExpandedString(int[])">toExpandedString</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">this method differs from toString() above in that is always tries
 to fully expand the namespace of an URI (if present)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#toString(int[])">toString</a></strong>(int[]&nbsp;tuple)</code>
<div class="block">generates an external string representation from the internal int[]
 representation of a tuple</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private boolean</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#tupleDeletionEnabled()">tupleDeletionEnabled</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#writeExpandedTuples(java.lang.String)">writeExpandedTuples</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">this method differs from writeTuples() above in that it always tries to
 fully expand the namespace of an URI when writing out tuples</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#writeTuples(java.util.Collection,%20java.lang.String)">writeTuples</a></strong>(java.util.Collection&lt;int[]&gt;&nbsp;collection,
           java.lang.String&nbsp;filename)</code>
<div class="block">a simple version that writes all tuple from the tuple store to a file using
 the external representation (encoding: UTF-16);
 intended file extension is '.nt' (to indicate N-Tiple syntax)
 can be used to iterate over lists or sets</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#writeTuples(java.lang.String)">writeTuples</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">a simple version that writes all tuple from the tuple store to a file using
 the external representation;
 intended file extension is '.nt' (to indicate N-Tiple syntax)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../../de/dfki/lt/hfc/TupleStore.html#writeTupleStore(java.lang.String)">writeTupleStore</a></strong>(java.lang.String&nbsp;filename)</code>
<div class="block">a simple version that writes the relevant parts of a tuple store to a file, using
 a specific format; much faster than Java's serialization;
 intended file extension is '.ts' (for tuple store)</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="generation">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generation</h4>
<pre>protected&nbsp;int generation</pre>
<div class="block">this field serves a different purpose compared to field ForwardChainer.generationCounter
 and is solely used when tuple deletion is enabled in the forward chainer;
 this field is incremented by 1 before closure computation is called and is incremented
 again after closure computation;
 this strategy makes sure that the entailed tuples are assigned an ODD generation number,
 whereas uploaded tuples are automatically assigned an EVEN number</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.enableTupleDeletion()</code></dd></dl>
</li>
</ul>
<a name="tupleToGeneration">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tupleToGeneration</h4>
<pre>protected&nbsp;<any> tupleToGeneration</pre>
<div class="block">a special field that is initialized by an empty map from tuples (int[]) to generations
 (Integer) in case tuple deletion is switched on through method enableTupleDeletion() in
 the forward chainer</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.enableTupleDeletion()</code></dd></dl>
</li>
</ul>
<a name="equivalenceClassReduction">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equivalenceClassReduction</h4>
<pre>public&nbsp;boolean equivalenceClassReduction</pre>
<div class="block">an optimization, currently applicable only to
   + owl:sameAs
   + owl:equivalentClass
   + owl:equivalentProperty
 but not to general equivalence relations, i.e., relations which are
 reflexive, symmetric, and transitive;
 this optimization influences input/output of methods from the following
 Java classes:
   + TupleStore
   + RuleStore
   + Query
 NOTE: once tuples have been read into the tuple store, do NOT change the
       value of _this_ field !!
 NOTE: assigning a URI (in subject or object position) to different equivalence
       relations, e.g.,
         <a> <owl:sameAs> <b>
         <a> <owl:equivalentProperty> <c>
       might lead to wrong results when querying a repository (at the same time,
       this is only allowed in OWL Full);
 NOTE: make sure to load the right rule file, depending on the value of this
       field!!</div>
</li>
</ul>
<a name="SUBJECT_POSITION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SUBJECT_POSITION</h4>
<pre>public static final&nbsp;int SUBJECT_POSITION</pre>
<div class="block">specifies the position of the subject, predicate, and object in an RDF triple
   0 : subject
   1 : predicate
   2 : object
 in case we would move the predicate to the front, predicatePosition must be
 set to 0, subject to 1, and object to 2, even if we would allow for tuples
 of length > 3 (interpret this as "the object, given as a Cartesian product,
 starts at position 2)</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../constant-values.html#de.dfki.lt.hfc.TupleStore.SUBJECT_POSITION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="PREDICATE_POSITION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>PREDICATE_POSITION</h4>
<pre>public static final&nbsp;int PREDICATE_POSITION</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../constant-values.html#de.dfki.lt.hfc.TupleStore.PREDICATE_POSITION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="OBJECT_POSITION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OBJECT_POSITION</h4>
<pre>public static final&nbsp;int OBJECT_POSITION</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../constant-values.html#de.dfki.lt.hfc.TupleStore.OBJECT_POSITION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="INPUT_CHARACTER_ENCODING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>INPUT_CHARACTER_ENCODING</h4>
<pre>public static final&nbsp;java.lang.String INPUT_CHARACTER_ENCODING</pre>
<div class="block">this setting is used for input encoding in TupleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.OUTPUT_CHARACTER_ENCODING</code>, 
<code>Interactive.OUTPUT_CHARACTER_ENCODING</code>, 
<a href="../../../../constant-values.html#de.dfki.lt.hfc.TupleStore.INPUT_CHARACTER_ENCODING">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="OUTPUT_CHARACTER_ENCODING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>OUTPUT_CHARACTER_ENCODING</h4>
<pre>public static final&nbsp;java.lang.String OUTPUT_CHARACTER_ENCODING</pre>
<div class="block">this setting is used for output encoding in TupleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.INPUT_CHARACTER_ENCODING</code>, 
<code>Interactive.OUTPUT_CHARACTER_ENCODING</code>, 
<a href="../../../../constant-values.html#de.dfki.lt.hfc.TupleStore.OUTPUT_CHARACTER_ENCODING">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="uriToProxy">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uriToProxy</h4>
<pre>protected&nbsp;TIntIntHashMap uriToProxy</pre>
<div class="block">a mapping from the internal representation of URIs (ints) to their
 representatives/proxies, again internal representation of URIs;
 only URIs mentioned in sameAs, equivalentClass, and equivalentProperty
 statements are entered here (at the moment)</div>
</li>
</ul>
<a name="proxyToUris">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>proxyToUris</h4>
<pre>protected&nbsp;<any> proxyToUris</pre>
<div class="block">a mapping from a proxy to its equivalence class, represented as an
 array list of ints</div>
</li>
</ul>
<a name="uriToEquivalenceRelation">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uriToEquivalenceRelation</h4>
<pre>protected&nbsp;TIntIntHashMap uriToEquivalenceRelation</pre>
<div class="block">a mapping from URI in subject/object position to the equivalence
 relation name (internal ID) in predicate position</div>
</li>
</ul>
<a name="minNoOfArgs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>minNoOfArgs</h4>
<pre>public&nbsp;int minNoOfArgs</pre>
<div class="block">it seems reasonable to have tuples of at least length 1;
 use value 3 to be compliant with RDF;
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>#maxNoOfARgs</code></dd></dl>
</li>
</ul>
<a name="maxNoOfArgs">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>maxNoOfArgs</h4>
<pre>public&nbsp;int maxNoOfArgs</pre>
<div class="block">this constant is used to create the right number of index tables;
 note that the value of this constant has an effect on the index data
 structure; the larger the number, the more tables are created;
 reasonable values seem to be 3 (RDF triple), 4 (time or negation, 5 (time),
 or 6 (time and negation);
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>#minNoOfARgs</code></dd></dl>
</li>
</ul>
<a name="verbose">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verbose</h4>
<pre>private&nbsp;boolean verbose</pre>
<div class="block">a constant that controls whether a warning is printed in case an invalid
 tuple is read in;
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/TupleStore.html#exitOnError"><code>exitOnError</code></a></dd></dl>
</li>
</ul>
<a name="rdfCheck">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rdfCheck</h4>
<pre>public&nbsp;boolean rdfCheck</pre>
<div class="block">when tuples are read in, this variable decides whether tuples are compliant with
 what RDF requests, viz., that the first argument is either an URI or a blank node,
 and that the second arg is a URI</div>
</li>
</ul>
<a name="exitOnError">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>exitOnError</h4>
<pre>public&nbsp;boolean exitOnError</pre>
<div class="block">a constant that controls whether the system is terminated in case an invalid
 tuple is read in (exit code = 1);
 a similar variable exists in class RuleStore</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/TupleStore.html#verbose"><code>verbose</code></a></dd></dl>
</li>
</ul>
<a name="currentId">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>currentId</h4>
<pre>private&nbsp;int currentId</pre>
<div class="block">URIs and XSD literals are replaced when they are read in by their IDs,
 usually ints (perhaps use longs if there are too many atoms), starting
 with 0
 the value 0 is used during rule application to indicate that a variable
 is unbound or its value is not of interest;
 negative integers represent (local) variable names</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>TupleStore.INTERNAL_UNBOUND</code></dd></dl>
</li>
</ul>
<a name="namespace">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>namespace</h4>
<pre>protected&nbsp;<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a> namespace</pre>
<div class="block">a namespace object used to expand short form namespaces into full forms</div>
</li>
</ul>
<a name="objectToId">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>objectToId</h4>
<pre>protected&nbsp;java.util.HashMap&lt;java.lang.String,java.lang.Integer&gt; objectToId</pre>
<div class="block">used during input, when URIs, blank nodes, or XSD atoms are replaced by their IDs (ints)</div>
</li>
</ul>
<a name="idToObject">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idToObject</h4>
<pre>protected&nbsp;java.util.ArrayList&lt;java.lang.String&gt; idToObject</pre>
<div class="block">used during output, when IDs (ints) are replaced by URI or XSD names</div>
</li>
</ul>
<a name="idToJavaObject">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idToJavaObject</h4>
<pre>protected&nbsp;java.util.ArrayList&lt;<a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&gt; idToJavaObject</pre>
<div class="block">a mapping used by functional constraints to speed up processing</div>
</li>
</ul>
<a name="index">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>index</h4>
<pre>protected&nbsp;java.util.Map&lt;java.lang.Integer,java.util.Set&lt;int[]&gt;&gt;[] index</pre>
<div class="block">the index data structure is used to find all those tuples which contain an
 object represented as an int at a specific position;

 NOTE: it _might_ be better to use Trove's TIntObjectHashMap class here
       checked it, even slightly _worse_ (HUK)</div>
</li>
</ul>
<a name="allTuples">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allTuples</h4>
<pre>protected&nbsp;java.util.Set&lt;int[]&gt; allTuples</pre>
<div class="block">a set of all tuples known to TupleStore</div>
</li>
</ul>
<a name="DEFAULT_HASHING_STRATEGY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_HASHING_STRATEGY</h4>
<pre>protected static&nbsp;<a href="../../../../de/dfki/lt/hfc/TIntArrayHashingStrategy.html" title="class in de.dfki.lt.hfc">TIntArrayHashingStrategy</a> DEFAULT_HASHING_STRATEGY</pre>
<div class="block">the default hashing (and equals) strategy for tuples from the tuple store
 (all positions of a tuple are taken into account);
 make it static, so that it can be reused for the sets at the leaves of the
 index!</div>
</li>
</ul>
<a name="operatorRegistry">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>operatorRegistry</h4>
<pre>protected&nbsp;<a href="../../../../de/dfki/lt/hfc/OperatorRegistry.html" title="class in de.dfki.lt.hfc">OperatorRegistry</a> operatorRegistry</pre>
<div class="block">this registry object gathers the functional operators potentially used
 during querying (FILTER) and forward chaining (LHS matching via predicates
 and RHS generation of new individuals via functions), and so during the
 interactive mode;
 since all these modes need a tuple store and since the registry requires
 the tuple store as an internal state, we automatically constructs a new
 registry every time a new tuple store is build</div>
</li>
</ul>
<a name="aggregateRegistry">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>aggregateRegistry</h4>
<pre>protected&nbsp;<a href="../../../../de/dfki/lt/hfc/AggregateRegistry.html" title="class in de.dfki.lt.hfc">AggregateRegistry</a> aggregateRegistry</pre>
<div class="block">this registry object gathers the aggregational operators potentially used
 during querying (AGGREGATE) and forward chaining (all-rules), and so during
 the interactive mode;
 since all these modes need a tuple store and since the registry requires
 the tuple store as an internal state, we automatically constructs a new
 registry every time a new tuple store is build</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="TupleStore()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>private&nbsp;TupleStore()</pre>
<div class="block">(should) only (be) used by copyTupleStore()</div>
</li>
</ul>
<a name="TupleStore(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples)</pre>
<div class="block">choose a proper noOfAtoms/noOfTuples in order not to arrive at copying the
 elements into a larger structure; keep in mind that other services (e.g.,
 rule application) can drastically increase the number of tuples</div>
</li>
</ul>
<a name="TupleStore(int, int, de.dfki.lt.hfc.Namespace)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</pre>
<div class="block">extends the binary constructor with the ability to read in a namespace</div>
</li>
</ul>
<a name="TupleStore(int, int, de.dfki.lt.hfc.Namespace, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</pre>
<div class="block">extends the binary constructor with the ability to read in a namespace and a
 textual representation of facts (basically N-Triples syntax), stored in a file</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/TupleStore.html#readTuples(java.lang.String)"><code>readTuples(java.lang.String)</code></a></dd></dl>
</li>
</ul>
<a name="TupleStore(boolean, boolean, boolean, int, int, int, int, de.dfki.lt.hfc.Namespace, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(boolean&nbsp;verbose,
          boolean&nbsp;rdfCheck,
          boolean&nbsp;eqReduction,
          int&nbsp;minNoOfArgs,
          int&nbsp;maxNoOfArgs,
          int&nbsp;noOfAtoms,
          int&nbsp;noOfTuples,
          <a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</pre>
<div class="block">more options to fully parameterize the tuple store</div>
</li>
</ul>
<a name="TupleStore(de.dfki.lt.hfc.Namespace)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</pre>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</li>
</ul>
<a name="TupleStore(de.dfki.lt.hfc.Namespace, java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>TupleStore</h4>
<pre>public&nbsp;TupleStore(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace,
          java.lang.String&nbsp;tupleFile)</pre>
<div class="block">assumes a default of 100,000 atoms and 500,000 tuples</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="tupleDeletionEnabled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tupleDeletionEnabled</h4>
<pre>private&nbsp;boolean&nbsp;tupleDeletionEnabled()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>true iff tuple deletion has been enabled by method ForwardChainer.enableTupleDeletion()</dd><dt><span class="strong">See Also:</span></dt><dd><code>ForwardChainer.tupleDeletionEnabled()</code></dd></dl>
</li>
</ul>
<a name="init(boolean, boolean, boolean, int, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre>private&nbsp;void&nbsp;init(boolean&nbsp;verbose,
        boolean&nbsp;rdfCheck,
        boolean&nbsp;eqReduction,
        int&nbsp;minNoOfArgs,
        int&nbsp;maxNoOfArgs,
        int&nbsp;noOfAtoms,
        int&nbsp;noOfTuples)</pre>
<div class="block">init form that "outsources" initialization code that needs to be duplicated by the
 binary (that is used be several other constructors) and 8-ary constructor</div>
</li>
</ul>
<a name="initializeUriMappings()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initializeUriMappings</h4>
<pre>private&nbsp;void&nbsp;initializeUriMappings()</pre>
<div class="block">specify mappings here that stay constant for efficiency reasons, independent of
 whether these URIs are seen first at different places in a file that is read in;
 currently, the following mappings are predefined for the following URIs (URI : id):
   NULL : 0, commented out at the moment, since it might interfere with Calc.restrict()
   rdfs:subClassOf : 1
   owl:sameAs : 2
   owl:equivalentClass : 3
   owl:equivalentProperty : 4
   owl:disjointWith : 5</div>
</li>
</ul>
<a name="printTuple(int[], java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printTuple</h4>
<pre>public static&nbsp;void&nbsp;printTuple(int[]&nbsp;tuple,
              java.util.ArrayList&lt;java.lang.String&gt;&nbsp;mapping)</pre>
<div class="block">a simple STATIC method, translating an int array into something readable (N-tuple syntax)</div>
</li>
</ul>
<a name="addEquivalentElements(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addEquivalentElements</h4>
<pre>protected&nbsp;void&nbsp;addEquivalentElements(int&nbsp;left,
                         int&nbsp;right)</pre>
<div class="block">three cases to distinguish here:
 (1) left and right are _not_ keys in uriToProxy
 (2) left xor right is a key in uriToProxy
 (3) left and right are keys in uriToProxy

 NOTE: we do make this method synchronized, since certain rule operators
       use this method</div>
</li>
</ul>
<a name="isEquivalenceRelation(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isEquivalenceRelation</h4>
<pre>protected&nbsp;boolean&nbsp;isEquivalenceRelation(int[]&nbsp;tuple)</pre>
<div class="block">given a tuple, isEquivalenceRelation() determines whether the predicate
 in position this.predicatePosition is an equivalence relation;
 currently, owl:sameAs, owl:equivalentClass, and owl:equivalentProperty
 are recognized here as given by the integers
   Namespace.OWL_SAMEAS_ID
   Namespace.OWL_EQUIVALENTCLASS_ID
   Namespace.OWL_EQUIVALENTPROPERTY_ID</div>
</li>
</ul>
<a name="getProxy(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProxy</h4>
<pre>protected final&nbsp;int&nbsp;getProxy(int&nbsp;uri)</pre>
<div class="block">returns the proxy for URI uri iff uri is a key in uriToProxy;
 otherwise, uri is returned</div>
</li>
</ul>
<a name="cleanUpTupleStore()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cleanUpTupleStore</h4>
<pre>public&nbsp;int&nbsp;cleanUpTupleStore()</pre>
<div class="block">remove those tuples from the set of all tuples and from the index which have
 an equivalence relation in predicate position;
 only keep exactly one triple for each proxy p with its corresponding equivalence relation r:
   p r p</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of tuples being removed</dd><dt><span class="strong">See Also:</span></dt><dd><code>isEquivalenceRelation()</code>, 
<code>RuleStore.generateTest()</code>, 
<code>RuleStore.generateAction()</code>, 
<code>removeTuple()</code></dd></dl>
</li>
</ul>
<a name="getNextId()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNextId</h4>
<pre>private&nbsp;int&nbsp;getNextId()</pre>
<div class="block">return a brand new id, resulting from the very last id, incremeted by 1 (values 0--5
 are reserved)</div>
</li>
</ul>
<a name="putObject(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>putObject</h4>
<pre>public&nbsp;int&nbsp;putObject(java.lang.String&nbsp;obj)</pre>
<div class="block">obj is either a URI or an XSD literal, encoded as a string;
 in case obj has not been seen before, the method assigns a new id (an int) to
 obj, establishes a bidirectional mapping between obj and id, and returns the
 new id;  otherwise, the already existing id for obj is returned</div>
</li>
</ul>
<a name="getObject(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getObject</h4>
<pre>public&nbsp;java.lang.String&nbsp;getObject(int&nbsp;id)</pre>
<div class="block">returns the the textual representation for id (an int);
 notice that since tuples are not always grounded (since they are
 used in the antecedent and consequent of a rule, where variables occur),
 we return the id prefixed by '?' in case id encodes a variable</div>
</li>
</ul>
<a name="getJavaObject(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getJavaObject</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&nbsp;getJavaObject(int&nbsp;id)</pre>
<div class="block">returns a Java object for a given literal, internally represented by parameter id;
 Java classes have been defined for the following types of literals:
   URI            -> de.dfki.lt.hfc.types.Uri
   blank node     -> de.dfki.lt.hfc.types.BlankNode
   xsd:int        -> de.dfki.lt.hfc.types.XsdInt
   xsd:long       -> de.dfki.lt.hfc.types.XsdLong
   xsd:float      -> de.dfki.lt.hfc.types.XsdFloat
   xsd:double     -> de.dfki.lt.hfc.types.XsdDouble
   xsd:string     -> de.dfki.lt.hfc.types.XsdString
   xsd:boolean    -> de.dfki.lt.hfc.types.XsdBoolean
   xsd:dateTime   -> de.dfki.lt.hfc.types.XsdDateTime
   xsd:date       -> de.dfki.lt.hfc.types.XsdDate
   xsd:gYear      -> de.dfki.lt.hfc.types.XsdGYear
   xsd:gYearMonth -> de.dfki.lt.hfc.types.XsdGYearMonth
   xsd:gMonth     -> de.dfki.lt.hfc.types.XsdGMonth
   xsd:gMonthDay  -> de.dfki.lt.hfc.types.XsdGMonthDay
   xsd:gDay       -> de.dfki.lt.hfc.types.XsdGDay
   xsd:duration   -> de.dfki.lt.hfc.types.XsdDuration
   xsd:uDateTime  -> de.dfki.lt.hfc.types.XsdUDateTime
   xsd:monetary   -> de.dfki.lt.hfc.types.XsdMonetary
   xsd:anyURI     -> de.dfki.lt.hfc.types.XsdAnyURI

 this is a lazy method, calling makeJavaObject() in case no Java object has been
 created so far for id</div>
</li>
</ul>
<a name="makeJavaObject(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeJavaObject</h4>
<pre>private&nbsp;<a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&nbsp;makeJavaObject(int&nbsp;id)</pre>
<div class="block">for each new URI, blank node, or XSD atom, we construct a new Java
 object on _demand_ when calling makeJavaObject();
 the idea is that external functional operators will proceed faster
 when directly working on the Java objects instead on working on the
 external string representation which needs to be manipulated;
 Java classes have been defined for the following kinds of literals:
   URI            -> de.dfki.lt.hfc.types.Uri
   blank node     -> de.dfki.lt.hfc.types.BlankNode
   xsd:int        -> de.dfki.lt.hfc.types.XsdInt
   xsd:long       -> de.dfki.lt.hfc.types.XsdLong
   xsd:float      -> de.dfki.lt.hfc.types.XsdFloat
   xsd:double     -> de.dfki.lt.hfc.types.XsdDouble
   xsd:string     -> de.dfki.lt.hfc.types.XsdString
   xsd:boolean    -> de.dfki.lt.hfc.types.XsdBoolean
   xsd:dateTime   -> de.dfki.lt.hfc.types.XsdDateTime
   xsd:date       -> de.dfki.lt.hfc.types.XsdDate
   xsd:gYear      -> de.dfki.lt.hfc.types.XsdGYear
   xsd:gYearMonth -> de.dfki.lt.hfc.types.XsdGYearMonth
   xsd:gMonth     -> de.dfki.lt.hfc.types.XsdGMonth
   xsd:gMonthDay  -> de.dfki.lt.hfc.types.XsdGMonthDay
   xsd:gDay       -> de.dfki.lt.hfc.types.XsdGDay
   xsd:duration   -> de.dfki.lt.hfc.types.XsdDuration
   xsd:uDateTime  -> de.dfki.lt.hfc.types.XsdUDateTime
   xsd:monetary   -> de.dfki.lt.hfc.types.XsdMonetary
   xsd:anyURI     -> de.dfki.lt.hfc.types.XsdAnyURI

 NOTE: if further (XSD) types are added, this method needs to be adjusted
       as well as the Namespace class
 NOTE: in case we we have found an unknown literal type, null is returned
       and a message is printed out to the console</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>getJavaObject()</code></dd></dl>
</li>
</ul>
<a name="registerJavaObject(java.lang.String, de.dfki.lt.hfc.types.AnyType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>registerJavaObject</h4>
<pre>public&nbsp;int&nbsp;registerJavaObject(java.lang.String&nbsp;literal,
                     <a href="../../../../de/dfki/lt/hfc/types/AnyType.html" title="class in de.dfki.lt.hfc.types">AnyType</a>&nbsp;javaObject)</pre>
<div class="block">this synchronized method can be called by functional operators in order
 to establish an association between a literal (e.g., URI, XSD string, XSD
 int, etc.) and a Java object (subtypes of AnyType);
 furthermore, a new int (an ID) is returned that is internally used in the
 tuple store</div>
</li>
</ul>
<a name="sayItLoud(int, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sayItLoud</h4>
<pre>private&nbsp;boolean&nbsp;sayItLoud(int&nbsp;lineNo,
                java.lang.String&nbsp;message)</pre>
<div class="block">at several places, messages were output depending on this.exitOnError
 and this.verbose -- unify this in this special private method;
 perhaps will be replaced by Apache's log4j</div>
</li>
</ul>
<a name="sayItLoud(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sayItLoud</h4>
<pre>private&nbsp;boolean&nbsp;sayItLoud(java.lang.String&nbsp;message)</pre>
<div class="block">same method without the line numbering</div>
</li>
</ul>
<a name="isValidTuple(java.util.ArrayList, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValidTuple</h4>
<pre>public&nbsp;boolean&nbsp;isValidTuple(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple,
                   int&nbsp;lineNo)</pre>
<div class="block">checks whether a tuple of proper length as specified by this.minNoOfArgs
 and this.maxNoOfArgs;

 also checks whether the arguments of a tuple are of the right "kind":
   arg 1: URI or blank node
   arg 2: URI
   arg 3, 4, ... : URI, blank node or XSD atom
 thus only make sure that first and second arg are OK;

 finally check whether in case of a XSD atom, the atom is compatible
 with the specified XSD type
 ************************ NOT IMPLEMENTED YET ************************

 depending on this.verbose and this.exitOnError, the method is
 silent, outputs a warning, or exit the process</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../../de/dfki/lt/hfc/RuleStore.html#isValidTuple(java.util.ArrayList)"><code>RuleStore.isValidTuple(java.util.ArrayList&lt;java.lang.String&gt;)</code></a></dd></dl>
</li>
</ul>
<a name="isUri(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isUri</h4>
<pre>public static&nbsp;boolean&nbsp;isUri(java.lang.String&nbsp;literal)</pre>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isUri() returns true iff literal is a URI; false, otherwise</div>
</li>
</ul>
<a name="isUri(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isUri</h4>
<pre>public&nbsp;boolean&nbsp;isUri(int&nbsp;id)</pre>
<div class="block">given an id (an int), returns true iff id represents a URI;
 false, otherwise</div>
</li>
</ul>
<a name="isBlankNode(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBlankNode</h4>
<pre>public static&nbsp;boolean&nbsp;isBlankNode(java.lang.String&nbsp;literal)</pre>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isBlankNode() returns true iff literal is a blank node; false, otherwise</div>
</li>
</ul>
<a name="isBlankNode(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBlankNode</h4>
<pre>public&nbsp;boolean&nbsp;isBlankNode(int&nbsp;id)</pre>
<div class="block">given an id (an int), returns true iff id represents a blank node;
 false, otherwise</div>
</li>
</ul>
<a name="isAtom(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isAtom</h4>
<pre>public static&nbsp;boolean&nbsp;isAtom(java.lang.String&nbsp;literal)</pre>
<div class="block">given a string representation of a literal (an argument of a tuple),
 isAtom() returns true iff literal is an XSD atom; false, otherwise</div>
</li>
</ul>
<a name="isAtom(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isAtom</h4>
<pre>public&nbsp;boolean&nbsp;isAtom(int&nbsp;id)</pre>
<div class="block">given an id (an int), returns true iff id represents a XSD atom;
 false, otherwise</div>
</li>
</ul>
<a name="isConstant(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isConstant</h4>
<pre>public&nbsp;boolean&nbsp;isConstant(java.lang.String&nbsp;literal)</pre>
<div class="block">tests whether literal is a constant (i.e., URI, blank node, or XSD atom) as known
 by the tuple store; i.e., literal must be part of a tuple that has been added to
 the tuple store;
 NOTE: false does NOT indicate that literal is a variable!</div>
</li>
</ul>
<a name="isConstant(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isConstant</h4>
<pre>public static&nbsp;boolean&nbsp;isConstant(int&nbsp;id)</pre>
<div class="block">internal representation: constants are positive numbers</div>
</li>
</ul>
<a name="internalizeTuple(java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>internalizeTuple</h4>
<pre>public&nbsp;int[]&nbsp;internalizeTuple(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple)</pre>
<div class="block">internalizeTuple() maps array lists of strings to int arrays of unique
 ints;
 uses putObject() to generate new ints in case the string argument is
 brand new, or retrieves the already generated int in case the string
 argument has already been seen</div>
</li>
</ul>
<a name="internalizeTuple(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>internalizeTuple</h4>
<pre>public&nbsp;int[]&nbsp;internalizeTuple(java.lang.String[]&nbsp;stringTuple)</pre>
<div class="block">internalizeTuple() maps string arrays to int arrays of unique ints;
 uses putObject() to generate new ints in case the string argument is
 brand new, or retrieves the already generated int in case the string
 argument has already been seen</div>
</li>
</ul>
<a name="addTuple(java.util.ArrayList, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTuple</h4>
<pre>protected&nbsp;int[]&nbsp;addTuple(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;stringTuple,
             int&nbsp;lineNo)</pre>
<div class="block">addTuple() assumes a textual tuple representation after tokenization
 (an array list of strings);
 the bidirectional mapping is established and the index is updated;
 this method is used when an external tuple file is read in;
 lineNo refers to the line number in the file that is read in</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>null iff the tuple representation is illegal OR the tuple is
         already contained in the tuple store</dd></dl>
</li>
</ul>
<a name="addTuple(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTuple</h4>
<pre>public&nbsp;boolean&nbsp;addTuple(java.lang.String[]&nbsp;stringTuple)</pre>
<div class="block">addTuple(String[]) performs the internalization and then calls addTuple(int[])</div>
</li>
</ul>
<a name="addTuple(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTuple</h4>
<pre>public final&nbsp;boolean&nbsp;addTuple(int[]&nbsp;tuple)</pre>
<div class="block">addTuple() assumes an int[] as input (the tuple);
 the mappings are established and the index is updated;
 this method does not check whether the representation is valid;
 addTuple() also adds the tuple to the set of all tuples;
 if tuple deletion is enabled, addTuple() also updates the tuple-
 to-generation mapping;
 returns true iff the set of all tuple did not already contain the
 argument tuple</div>
</li>
</ul>
<a name="addTupleWithGeneration(int[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addTupleWithGeneration</h4>
<pre>protected final&nbsp;void&nbsp;addTupleWithGeneration(int[]&nbsp;tuple,
                          int&nbsp;gennum)</pre>
<div class="block">helper for cleanUpTupleStore;
 differs from addTuple(int[]) in that it carries a second argument, the
 generation (an int) that is used as the generation for the tuple argument
 in case tuple deletion is enabled</div>
</li>
</ul>
<a name="addToIndex(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addToIndex</h4>
<pre>public&nbsp;void&nbsp;addToIndex(int[]&nbsp;tuple)</pre>
<div class="block">I separated this code from the addTuple method above to make it
 accessible from other classes</div>
</li>
</ul>
<a name="getTuples(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTuples</h4>
<pre>public&nbsp;java.util.Set&lt;int[]&gt;&nbsp;getTuples(int&nbsp;pos,
                             int&nbsp;obj)</pre>
<div class="block">obtains all those tuples which contain an object obj (represented as an int)
 at a specific position pos in a tuple (an int);
 NOTE: the set which is returned is part of the index and thus should NOT be
       modified!!!</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a set of matching tuples which have obj at position pos</dd></dl>
</li>
</ul>
<a name="getTuples(int, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTuples</h4>
<pre>public&nbsp;java.util.Set&lt;int[]&gt;&nbsp;getTuples(int&nbsp;pos,
                             java.lang.String&nbsp;obj)</pre>
<div class="block">instead of using the obj id (an int), one can alternatively specify the object
 directly;
 NOTE: check whether you must use the short or long namespace prefix depending on
       Namespace.shortIsDefault</div>
</li>
</ul>
<a name="getAllTuples()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllTuples</h4>
<pre>public&nbsp;java.util.Set&lt;int[]&gt;&nbsp;getAllTuples()</pre>
<div class="block">returns the set of all tuples</div>
</li>
</ul>
<a name="removeTuple(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeTuple</h4>
<pre>public final&nbsp;boolean&nbsp;removeTuple(int[]&nbsp;tuple)</pre>
<div class="block">removes the tuple from the set of all tuples and cleans up the index structure;
 if tuple deletion is enabled, the tuple-generation pair is also removed from the
 tuple-to-generation mapping;
 returns true iff the set of all tuples contained the specified tuple;
 false otherwise (= nothing is removed)</div>
</li>
</ul>
<a name="removeTupleReturnGeneration(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeTupleReturnGeneration</h4>
<pre>protected final&nbsp;int&nbsp;removeTupleReturnGeneration(int[]&nbsp;tuple)</pre>
<div class="block">differs from removeTuple() in that it returns the generation of the tuple
 that is going to be deleted;
 returns -1 in case the tuple is not part of the repository</div>
</li>
</ul>
<a name="readTuples(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readTuples</h4>
<pre>public&nbsp;void&nbsp;readTuples(java.lang.String&nbsp;filename)</pre>
<div class="block">readTuples() reads in a sequence of tuples from a text file;
 tuples must be finished in a _single_ line, constrained by the following
 side conditions:
   + a tuple starts with an URI or a blank node
   + tuples must have at least one argument
   + elements of a tuple (URIs, blank nodes, XSD atoms) must be separated
     by the space character ' '
   + URIs start with "<" and end with ">" (both for short and long prefixes)
   + blank nodes start with "_:"
   + XSD atoms start with '"' and ends with '"', potentially followed by type
     or language information; inside the leading string value, strings must
     be enclosed by "\""
   + comments only start with the '#' character at the very first position of
     a line
   + tuples need not end with the '.' character

 this is essentially N-Triples syntax, see
   Jan Grant & Dave Beckett: RDF Test Cases, 10 Feb 2004.
   http://www.w3.org/TR/rdf-testcases/

 note: if equivalence class reduction is switched on, the cleanup mechanism
       is always applied AFTER the whole file is read in, but not each time
       an equivalence relation instance is detected! (more efficient at the
       very end)

 example
   <huk> <rdf:type> <Person> .
   <huk> <dateOfBirth> "1960-08-14"^^<xsd:date> .
   <huk> <worksFor> <dfki> .
   <huk> <hasAge> "47"^^<xsd:int> .
   <huk> <hasName> _:foo42 .
   _:foo42 <firstName> "Uli" .
   _:foo42 <lastName> "Krieger" .</div>
</li>
</ul>
<a name="readTupleStore(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readTupleStore</h4>
<pre>protected&nbsp;java.util.Set&lt;int[]&gt;&nbsp;readTupleStore(java.lang.String&nbsp;filename)</pre>
<div class="block">reads in a 'compressed' tuple store (extension usually "ts") generated by
 writeTupleStore(); usage:
   Namespace ns = new Namespace("...");
   TupleStore ts = new TupleStore(ns);
   ts.readTupleStore("...");</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the set of ALL tuples stored in the this TupleStore instance</dd></dl>
</li>
</ul>
<a name="readObjectToId(java.io.BufferedReader, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readObjectToId</h4>
<pre>private&nbsp;void&nbsp;readObjectToId(java.io.BufferedReader&nbsp;br,
                  int&nbsp;noOfLines)
                     throws java.io.IOException</pre>
<div class="block">helper for readTupleStore()</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="readIdToObject(java.io.BufferedReader, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readIdToObject</h4>
<pre>private&nbsp;void&nbsp;readIdToObject(java.io.BufferedReader&nbsp;br,
                  int&nbsp;noOfLines)
                     throws java.io.IOException</pre>
<div class="block">helper for readTupleStore()</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="readAllTuples(java.io.BufferedReader, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readAllTuples</h4>
<pre>private&nbsp;void&nbsp;readAllTuples(java.io.BufferedReader&nbsp;br,
                 int&nbsp;noOfLines)
                    throws java.io.IOException</pre>
<div class="block">helper for readTupleStore()</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="parseURI(java.util.StringTokenizer, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseURI</h4>
<pre>protected&nbsp;java.lang.String&nbsp;parseURI(java.util.StringTokenizer&nbsp;st,
                        java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</pre>
<div class="block">a URI starts with a '<' and ends with a '>';</div>
</li>
</ul>
<a name="parseBlankNode(java.util.StringTokenizer, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseBlankNode</h4>
<pre>protected static&nbsp;void&nbsp;parseBlankNode(java.util.StringTokenizer&nbsp;st,
                  java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</pre>
<div class="block">a blank node starts with a "_:" and ends before the next whitespace character,
 i.e., no whitespaces are allowed inside the name of the blank node;
 since, blank nodes make no reference to a namespace, we make this a static method</div>
</li>
</ul>
<a name="parseAtom(java.util.StringTokenizer, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseAtom</h4>
<pre>protected&nbsp;java.lang.String&nbsp;parseAtom(java.util.StringTokenizer&nbsp;st,
                         java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</pre>
<div class="block">XSD atoms are strings optionally followed by either a type identifier (^^type)
 or a language tag (@lang);
 within the preceding string, further strings are allowed, surrounded by "\"",
 as well as spaces, "\\", etc.</div>
</li>
</ul>
<a name="parseVariable(java.util.StringTokenizer, java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parseVariable</h4>
<pre>protected static&nbsp;java.lang.String&nbsp;parseVariable(java.util.StringTokenizer&nbsp;st,
                             java.util.ArrayList&lt;java.lang.String&gt;&nbsp;tuple)</pre>
<div class="block">variables in a rule or query tuple start with a '?' char and are followed by a string,
 containing no whitespace chars;
 since variables make no reference to a namespace, we make this a static method</div>
</li>
</ul>
<a name="writeTuples(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeTuples</h4>
<pre>public&nbsp;void&nbsp;writeTuples(java.lang.String&nbsp;filename)</pre>
<div class="block">a simple version that writes all tuple from the tuple store to a file using
 the external representation;
 intended file extension is '.nt' (to indicate N-Tiple syntax)</div>
</li>
</ul>
<a name="writeTuples(java.util.Collection, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeTuples</h4>
<pre>public&nbsp;void&nbsp;writeTuples(java.util.Collection&lt;int[]&gt;&nbsp;collection,
               java.lang.String&nbsp;filename)</pre>
<div class="block">a simple version that writes all tuple from the tuple store to a file using
 the external representation (encoding: UTF-16);
 intended file extension is '.nt' (to indicate N-Tiple syntax)
 can be used to iterate over lists or sets</div>
</li>
</ul>
<a name="writeExpandedTuples(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeExpandedTuples</h4>
<pre>public&nbsp;void&nbsp;writeExpandedTuples(java.lang.String&nbsp;filename)</pre>
<div class="block">this method differs from writeTuples() above in that it always tries to
 fully expand the namespace of an URI when writing out tuples</div>
</li>
</ul>
<a name="writeTupleStore(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeTupleStore</h4>
<pre>public&nbsp;void&nbsp;writeTupleStore(java.lang.String&nbsp;filename)</pre>
<div class="block">a simple version that writes the relevant parts of a tuple store to a file, using
 a specific format; much faster than Java's serialization;
 intended file extension is '.ts' (for tuple store)</div>
</li>
</ul>
<a name="toString(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString(int[]&nbsp;tuple)</pre>
<div class="block">generates an external string representation from the internal int[]
 representation of a tuple</div>
</li>
</ul>
<a name="toExpandedString(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toExpandedString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toExpandedString(int[]&nbsp;tuple)</pre>
<div class="block">this method differs from toString() above in that is always tries
 to fully expand the namespace of an URI (if present)</div>
</li>
</ul>
<a name="ask(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre>public&nbsp;boolean&nbsp;ask(java.lang.String[]&nbsp;externalTuple)</pre>
<div class="block">checks whether a tuple (represented as a string array) is contained in the
 tuple store</div>
</li>
</ul>
<a name="ask(java.util.ArrayList)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre>public&nbsp;boolean&nbsp;ask(java.util.ArrayList&lt;java.lang.String&gt;&nbsp;externalTuple)</pre>
<div class="block">checks whether a tuple (represented as an array list of strings) is contained
 in the tuple store</div>
</li>
</ul>
<a name="ask(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ask</h4>
<pre>public&nbsp;boolean&nbsp;ask(int[]&nbsp;tuple)</pre>
<div class="block">use this method for containment test in order not to make this.allTuples public</div>
</li>
</ul>
<a name="matchPrefixPattern(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>matchPrefixPattern</h4>
<pre>protected&nbsp;java.util.Set&lt;int[]&gt;&nbsp;matchPrefixPattern(java.lang.String[]&nbsp;prefixPattern)</pre>
<div class="block">returns those ground tuples g = p+s, such that p matches the prefix pattern parameter;
 a pattern is composed of variables, URIs, and XSD atoms;
 note that the name of a variable does NOT matter, and thus a pattern such as
   ?s <foo> ?s <bar>
 does NOT enforce that the matching tuples must have identical values in first and third
 position;
 note that tuples must be at least as long as the pattern to be successfully matching
 candidates; so, for instance, w.r.t. the above pattern
   NO match: <bar> <foo>
      match: <bar> <foo> <baz> <bar>
      match: <bar> <foo> <baz> <bar> <yep>
 note further that a pattern should NOT be longer than the longest tuples in the
 repository;

 NOTE: we will return the EMPTY SET for patterns longer than the longest tuple
 
 NOTE: we will return the NULL VALUE for the EMPTY prefix pattern (even though ALL
       tuples match this pattern)

 NOTE: it makes perfect sense that the pattern contains AT LEAST ONE URI or XSD atom;
       checking for patterns containing only variables can be done more efficiently
       than by calling this method
       we will return the NULL VALUE for patterns consisting of variables only</div>
</li>
</ul>
<a name="containsPrefixPattern(java.lang.String[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>containsPrefixPattern</h4>
<pre>public&nbsp;boolean&nbsp;containsPrefixPattern(java.lang.String[]&nbsp;prefixPattern)</pre>
<div class="block">checks whether matchPrefixPattern() returns a NON-empty set
 NOTE: this method will only work for patterns not longer than the size of the index
       and for non-empty patterns and patterns not consisting of variables only</div>
</li>
</ul>
<a name="queryIndex(int[], de.dfki.lt.hfc.Table)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queryIndex</h4>
<pre>public&nbsp;java.util.Set&lt;int[]&gt;&nbsp;queryIndex(int[]&nbsp;pattern,
                              <a href="../../../../de/dfki/lt/hfc/Table.html" title="class in de.dfki.lt.hfc">Table</a>&nbsp;table)</pre>
<div class="block">queries the index, given a rule pattern, consisting of constants and variables;
 potentially performs several calls to the index using getTuples(), followed by
 non-destructive set intersection operations that take into account the "relevant
 positions" of the input pattern which influences the hashing strategy;
 NOTE: the result set is NOT shared by the index, thus can be destructively
       modified without having any effect on the index !!</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>a set of tuples satisfying the conditions given by pattern</dd></dl>
</li>
</ul>
<a name="ensureEqualVariables(java.util.Set, int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ensureEqualVariables</h4>
<pre>protected&nbsp;java.util.Set&lt;int[]&gt;&nbsp;ensureEqualVariables(java.util.Set&lt;int[]&gt;&nbsp;input,
                                        int[][]&nbsp;duplPos)</pre>
<div class="block">destructively reduces the input set by making sure that columns headed
 by the same variable hold the same value;
 example (duplPos vectors are _sorted_):
   rule pattern: <?x, ?y, ?x, ?y, ?x>
   duplPos: [[0, 2, 4], [1, 3]]
   input: <a, b, a, b, a>  OK!</div>
</li>
</ul>
<a name="copyTupleStore(de.dfki.lt.hfc.Namespace)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyTupleStore</h4>
<pre>public&nbsp;<a href="../../../../de/dfki/lt/hfc/TupleStore.html" title="class in de.dfki.lt.hfc">TupleStore</a>&nbsp;copyTupleStore(<a href="../../../../de/dfki/lt/hfc/Namespace.html" title="class in de.dfki.lt.hfc">Namespace</a>&nbsp;namespace)</pre>
<div class="block">returns a copy of the tuple store that can be used to generate "choice points",
 e.g., during reasoning, as is done by the forward chainer</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><code>de.dfki.lt.hfc.ForwardChainer.copyForwardChainer()</code></dd></dl>
</li>
</ul>
<a name="copyIndex()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyIndex</h4>
<pre>private&nbsp;java.util.Map&lt;java.lang.Integer,java.util.Set&lt;int[]&gt;&gt;[]&nbsp;copyIndex()</pre>
<div class="block">returns a nearly-deep copy of the index: everything is copied with the notable
 exception of the tuples (the int arrays) at the leaves of the index</div>
</li>
</ul>
<a name="main(java.lang.String[])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(java.lang.String[]&nbsp;args)
                 throws java.lang.Exception</pre>
<div class="block">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !!! FOR TEST PURPOSES ONLY !!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../de/dfki/lt/hfc/TupleComparator.html" title="class in de.dfki.lt.hfc"><span class="strong">Prev Class</span></a></li>
<li>Next Class</li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?de/dfki/lt/hfc/TupleStore.html" target="_top">Frames</a></li>
<li><a href="TupleStore.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
